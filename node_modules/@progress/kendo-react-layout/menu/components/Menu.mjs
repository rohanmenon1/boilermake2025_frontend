/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as m from "react";
import i from "prop-types";
import { Keys as d, validatePackage as f, classNames as v, dispatchEvent as b } from "@progress/kendo-react-common";
import { EMPTY_ID as r, getItemById as n, getDirectParentId as g, getRootParentId as R, isIdEmptyOrZeroLevel as a, ZERO_LEVEL_ZERO_ITEM_ID as u } from "../utils/itemsIdsUtils.mjs";
import { prepareInputItemsForInternalWork as D } from "../utils/prepareInputItemsForInternalWork.mjs";
import { getNewItemIdUponKeyboardNavigation as I } from "../utils/getNewItemIdUponKeyboardNavigation.mjs";
import { getHoverOpenDelay as H, getHoverCloseDelay as C } from "../utils/hoverDelay.mjs";
import { MenuItemInternalsList as O } from "./MenuItemInternal.mjs";
import { DirectionHolder as k } from "../utils/DirectionHolder.mjs";
import { MouseOverHandler as y } from "../utils/MouseOverHandler.mjs";
import { packageMetadata as L } from "../../package-metadata.mjs";
const p = {
  focusedItemId: r,
  hoveredItemId: r,
  tabbableItemId: u
}, l = class l extends m.Component {
  constructor(t) {
    super(t), this.menuWrapperEl = null, this.directionHolder = new k(), this.inputItems = [], this.items = [], this.reset = () => {
      this.clearItemHoverAndLeaveRequestsIfApplicable(), this.setState(p);
    }, this.onKeyDown = (e) => {
      if (this.state.focusedItemId !== r) {
        const s = n(this.state.focusedItemId, this.items);
        let o = I(
          this.items,
          s.id,
          e.keyCode,
          e.key,
          this.props.vertical,
          this.directionHolder.getIsDirectionRightToLeft()
        );
        const h = n(o, this.items);
        h && h.separator && (o = I(
          this.items,
          o,
          e.keyCode,
          e.key,
          this.props.vertical,
          this.directionHolder.getIsDirectionRightToLeft()
        )), s.id !== o && (e.preventDefault(), this.setFocusedItemId(o)), (e.keyCode === d.enter || e.keyCode === d.space) && !s.disabled && (this.mouseOverHandler.handleItemSelectedViaKeyboard(), this.dispatchSelectEventIfWired(e, s.id), !e.isDefaultPrevented() && s.items.length === 0 && s.url && window.location.assign(s.url));
      }
      e.keyCode === d.esc && this.props.onClose && this.props.onClose.call(void 0, e);
    }, this.onItemMouseOver = (e) => {
      this.mouseOverHandler.IsMouseOverEnabled && (this.clearItemHoverAndLeaveRequestsIfApplicable(), this.itemHoverRequest = window.setTimeout(() => {
        this.setHoveredItemId(e), this.itemHoverRequest = null;
      }, H(this.props)));
    }, this.onItemMouseLeave = (e) => {
      this.mouseOverHandler.IsMouseOverEnabled && this.isItemWithDefaultClose(e) && (this.clearItemHoverAndLeaveRequestsIfApplicable(), this.itemLeaveRequest = window.setTimeout(() => {
        this.setHoveredItemId(r), this.itemLeaveRequest = null;
      }, C(this.props)));
    }, this.onItemMouseDown = () => {
      this.mouseOverHandler.handleItemMouseDown();
    }, this.onItemFocus = (e) => {
      this.setFocusedItemId(e), this.mouseOverHandler.handleItemFocus();
    }, this.onItemClick = (e, s) => {
      const o = n(s, this.items);
      o.disabled || (this.setFocusedItemId(s), this.mouseOverHandler.handleItemClick(s, this.isItemWithDefaultClose(s)), this.dispatchSelectEventIfWired(e, s), !e.isDefaultPrevented() && o.url && window.location.assign(o.url));
    }, this.onItemBlur = (e, s) => {
      if (this.isItemWithDefaultClose(e) && this.setFocusedItemId(r), s.relatedTarget && s.relatedTarget.nodeName === "LI") {
        const o = s.relatedTarget.getAttribute("id");
        if (o && o.includes(this.menuItemId))
          return;
      }
      this.props.onClose && this.props.onClose.call(void 0, s);
    }, this.getInputItem = (e) => n(e, this.inputItems), f(L), this.mouseOverHandler = new y(this.props.openOnClick, this.reset, this.onItemMouseOver), this.state = Object.assign({}, p, { isFirstRender: !0 });
  }
  get menuItemId() {
    return this.props.id;
  }
  get element() {
    return this.menuWrapperEl;
  }
  /**
   * @hidden
   */
  render() {
    this.prepareItems(), this.state.isFirstRender || this.directionHolder.setIsDirectionRightToLeft(this.checkIsDirectionRightToLeft());
    const t = this.state.hoveredItemId ? this.state.hoveredItemId : this.state.focusedItemId ? g(this.state.focusedItemId) : r;
    return /* @__PURE__ */ m.createElement(
      "div",
      {
        id: this.props.id,
        onKeyDown: this.onKeyDown,
        style: this.props.style,
        className: this.directionHolder.getIsDirectionRightToLeft() ? "k-rtl" : void 0,
        ref: (e) => this.menuWrapperEl = e
      },
      /* @__PURE__ */ m.createElement(
        O,
        {
          className: this.getMenuClassName(),
          "aria-orientation": this.props.vertical ? "vertical" : void 0,
          items: this.items,
          isMenuVertical: this.props.vertical,
          isDirectionRightToLeft: this.directionHolder.getIsDirectionRightToLeft(),
          focusedItemId: this.state.focusedItemId,
          lastItemIdToBeOpened: t,
          tabbableItemId: this.state.tabbableItemId,
          itemRender: this.props.itemRender,
          linkRender: this.props.linkRender,
          menuGuid: this.menuItemId,
          onMouseLeave: this.onItemMouseLeave,
          onMouseOver: this.onItemMouseOver,
          onMouseDown: this.onItemMouseDown,
          onFocus: this.onItemFocus,
          onClick: this.onItemClick,
          onBlur: this.onItemBlur,
          onOriginalItemNeeded: this.getInputItem,
          role: this.props.role
        }
      )
    );
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.setState({ isFirstRender: !1 });
  }
  /**
   * @hidden
   */
  componentDidUpdate(t) {
    (!!t.vertical != !!this.props.vertical || this.directionHolder.hasDirectionChanged()) && this.reset(), this.mouseOverHandler.OpenOnClick = this.props.openOnClick;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.clearItemHoverAndLeaveRequestsIfApplicable();
  }
  setFocusedItemId(t) {
    this.setState((e) => {
      const s = t === r ? e.tabbableItemId : R(t);
      return { hoveredItemId: t === r || a(e.hoveredItemId) && a(t) ? e.hoveredItemId : r, focusedItemId: t, tabbableItemId: s };
    });
  }
  setHoveredItemId(t) {
    this.setState((e) => a(t) && a(e.focusedItemId) ? {
      hoveredItemId: t,
      focusedItemId: e.focusedItemId,
      tabbableItemId: e.tabbableItemId
    } : { hoveredItemId: t, focusedItemId: r, tabbableItemId: u });
  }
  getMenuClassName() {
    return v(
      "k-reset",
      "k-header",
      "k-menu",
      { "k-menu-horizontal": !this.props.vertical },
      { "k-menu-vertical": this.props.vertical },
      this.props.className
    );
  }
  clearItemHoverAndLeaveRequestsIfApplicable() {
    this.itemHoverRequest && (clearTimeout(this.itemHoverRequest), this.itemHoverRequest = null), this.itemLeaveRequest && (clearTimeout(this.itemLeaveRequest), this.itemLeaveRequest = null);
  }
  isItemWithDefaultClose(t) {
    return !this.props.customCloseItemIds || this.props.customCloseItemIds.indexOf(t) === -1;
  }
  checkIsDirectionRightToLeft() {
    return !!(this.props.dir !== void 0 ? this.props.dir === "rtl" : this.menuWrapperEl && getComputedStyle(this.menuWrapperEl).direction === "rtl");
  }
  prepareItems() {
    const { items: t, inputItems: e } = D(this.props.items, this.props.children);
    this.items = t, this.inputItems = e;
  }
  dispatchSelectEventIfWired(t, e) {
    b(this.props.onSelect, t, this, { item: this.getInputItem(e), itemId: e });
  }
};
l.propTypes = {
  vertical: i.bool,
  items: i.arrayOf(i.object),
  style: i.object,
  dir: i.string,
  hoverOpenDelay: i.number,
  hoverCloseDelay: i.number,
  openOnClick: i.bool,
  itemRender: i.any,
  linkRender: i.any,
  customCloseItemIds: i.arrayOf(i.string),
  onSelect: i.func,
  role: i.string
}, l.defaultProps = { vertical: !1 };
let c = l;
export {
  c as Menu
};
