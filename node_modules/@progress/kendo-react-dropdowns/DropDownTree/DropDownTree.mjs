/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import n from "prop-types";
import { createPropsContext as Ye, validatePackage as Ze, usePropsContext as et, useId as tt, getTabIndex as nt, useRtl as ot, useAdaptiveModeContext as at, canUseDOM as rt, Keys as c, noop as j, mapTree as it, extendDataItem as lt, classNames as ae, IconWrap as Fe, kendoThemeMaps as st } from "@progress/kendo-react-common";
import { Popup as ct } from "@progress/kendo-react-popup";
import { useLocalization as ut } from "@progress/kendo-react-intl";
import { TreeView as De } from "@progress/kendo-react-treeview";
import { packageMetadata as dt } from "../package-metadata.mjs";
import { getItemValue as pt, areSame as Ie, isPresent as mt } from "../common/utils.mjs";
import { useDropdownWidth as ft } from "./useDropdownWidth.mjs";
import { ListNoData as vt } from "./ListNoData.mjs";
import { clear as Se, messages as re, nodata as G } from "../messages/index.mjs";
import { FloatingLabel as gt } from "@progress/kendo-react-labels";
import Me from "../common/ListFilter.mjs";
import { Button as bt } from "@progress/kendo-react-buttons";
import { xIcon as ht, caretAltDownIcon as yt } from "@progress/kendo-svg-icons";
import { AdaptiveMode as Ct } from "../common/AdaptiveMode.mjs";
import { ActionSheetContent as Et } from "@progress/kendo-react-layout";
const { sizeMap: kt, roundedMap: xt } = st, wt = "Please select a value from the list!", Ft = (C) => /* @__PURE__ */ t.createElement("span", { className: "k-input-value-text" }, C.children), Re = (C) => C.split("_").map((D) => parseInt(D, 10)), Dt = (C, D) => {
  const { validationMessage: r, valid: a, required: U } = C;
  return {
    customError: r !== void 0,
    valid: !!(a !== void 0 ? a : !U || D),
    valueMissing: !D
  };
}, ie = {
  selectField: "selected",
  subItemsField: "items",
  popupSettings: {
    animate: !0,
    width: "200px",
    height: "200px"
  },
  data: [],
  required: !1,
  style: {},
  validityStyles: !0,
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
}, It = Ye(), Te = t.forwardRef((C, D) => {
  Ze(dt);
  const r = et(It, C), a = {
    ...ie,
    ...r
  }, U = tt(), le = a.id || U, {
    data: T,
    dataItemKey: N,
    popupSettings: b = {},
    style: P,
    opened: u,
    disabled: I,
    onOpen: V = j,
    onClose: m = j,
    placeholder: J,
    label: K,
    name: Ne,
    selectField: z,
    subItemsField: O,
    validationMessage: H,
    valid: Pe,
    required: Q,
    validityStyles: Ve
  } = a, X = nt(a.tabIndex, I), i = t.useRef(null), f = t.useRef(null), S = t.useRef(null), Y = t.useRef(null), $ = t.useRef(null), h = t.useRef(null), _ = t.useRef(!1), [se, Ke] = t.useState(void 0), E = a.value !== void 0, v = E ? a.value : se !== void 0 ? se : a.defaultValue, L = mt(v), Z = L ? pt(v, a.textField) : "", ee = Dt({ validationMessage: H, valid: Pe, required: Q }, L), Oe = t.useCallback(() => f.current && f.current.focus(), []);
  t.useImperativeHandle(i, () => ({
    props: a,
    element: f.current,
    focus: Oe
  })), t.useImperativeHandle(D, () => i.current);
  const k = ot(f, a.dir), Le = {
    width: ft(
      f,
      ie,
      { ...ie.popupSettings, ...b },
      P
    ),
    ...k !== void 0 ? { direction: k } : {}
  }, [Be, ce] = t.useState(!1), l = u !== void 0 ? u : Be, [d, te] = t.useState(!1), [ne, We] = t.useState(), [ue, qe] = t.useState(""), de = at(), x = !!(ne && de && ne <= de.medium && a.adaptive), Ae = t.useCallback(() => {
    $.current && $.current.setCustomValidity && $.current.setCustomValidity(
      ee.valid ? "" : H === void 0 ? wt : H
    );
  }, [H, ee]);
  t.useEffect(Ae), t.useEffect(() => {
    const e = rt && window.ResizeObserver && new window.ResizeObserver(Qe.bind(void 0));
    return document != null && document.body && e && e.observe(document.body), () => {
      document != null && document.body && e && e.disconnect();
    };
  }, []);
  const pe = t.useCallback(
    (e) => {
      if (!l) {
        if (V) {
          const o = { ...e };
          V.call(void 0, o);
        }
        u === void 0 && ce(!0);
      }
    },
    [l, u, V]
  ), w = t.useCallback(
    (e) => {
      if (l) {
        if (m) {
          const o = { ...e };
          m.call(void 0, o);
        }
        u === void 0 && (ce(!1), x && setTimeout(() => {
          var o;
          g((o = Y.current) == null ? void 0 : o.element);
        }, 300));
      }
    },
    [l, u, m, x]
  ), ze = t.useCallback(
    (e) => {
      if (!e.isDefaultPrevented() && i.current) {
        te(!0);
        const o = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: i.current
        };
        (l ? w : pe)(o);
      }
    },
    [l, u, V, m]
  ), M = t.useCallback((e) => {
    _.current = !0, e(), window.setTimeout(() => _.current = !1, 0);
  }, []), He = t.useCallback(
    (e) => {
      var F, xe;
      const { keyCode: o, altKey: s } = e, p = h.current && h.current.element;
      if (!i.current || e.isDefaultPrevented() && ((F = S.current) == null ? void 0 : F.element) === e.target)
        return;
      const R = {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        target: i.current
      };
      if (l)
        if (o === c.esc || s && o === c.up)
          e.preventDefault(), w(R);
        else if (p && p.querySelector(".k-focus") && (o === c.up || o === c.down || o === c.left || o === c.right || o === c.home || o === c.end)) {
          if (o === c.up && ((xe = S.current) != null && xe.element)) {
            const q = Array.from(p.querySelectorAll(".k-treeview-item")), we = [...q].reverse().find((A) => !!(A && A.querySelector(".k-focus")));
            if (we && q.indexOf(we) === 0)
              return M(() => {
                var A;
                g((A = S.current) == null ? void 0 : A.element);
              });
          }
          M(j);
        } else
          o === c.down && M(() => {
            var q;
            g(((q = S.current) == null ? void 0 : q.element) || p);
          });
      else
        s && o === c.down ? (e.preventDefault(), pe(R)) : l || o === c.esc && ge(e);
    },
    [l, u, V, m]
  ), me = t.useCallback((e) => {
    const { keyCode: o, altKey: s } = e;
    s || o !== c.up && o !== c.down || (e.preventDefault(), M(
      o === c.up ? () => {
        g(f.current);
      } : () => {
        g(h.current && h.current.element);
      }
    ));
  }, []), g = t.useCallback((e) => {
    e && M(() => e.focus());
  }, []), $e = t.useCallback(() => {
    var e;
    !d && l && !u ? w({ target: i.current }) : r.filterable ? g((e = S.current) == null ? void 0 : e.element) : g(h.current && h.current.element);
  }, [m, r.filterable, d, u, l]), _e = t.useCallback(() => {
    d && g(f.current);
  }, [d]), je = t.useCallback(
    (e) => {
      if (!d && !_.current && (te(!0), r.onFocus && i.current)) {
        const o = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: i.current
        };
        r.onFocus.call(void 0, o);
      }
    },
    [d, r.onFocus]
  ), Ge = t.useCallback(
    (e) => {
      if (d && !_.current && i.current) {
        te(!1);
        const o = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: i.current
        };
        if (r.onBlur) {
          const s = { ...o };
          r.onBlur.call(void 0, s);
        }
        x || w(o);
      }
    },
    [d, r.onBlur, l, u, m]
  ), Ue = t.useCallback(() => {
    d && M(j), x && setTimeout(() => {
      var e;
      g((e = Y.current) == null ? void 0 : e.element);
    }, 300);
  }, [d, x]), fe = t.useCallback(
    (e, o, s) => {
      if (r.onChange) {
        const p = {
          value: o,
          level: s ? Re(s) : [],
          ...e
        };
        r.onChange.call(void 0, p);
      }
      E || Ke(o);
    },
    [r.onChange, E]
  ), ve = t.useCallback(
    (e) => {
      if (Ie(e.item, v, N) || !i.current)
        return;
      const { item: o, itemHierarchicalIndex: s, nativeEvent: p, syntheticEvent: R } = e, F = {
        syntheticEvent: R,
        nativeEvent: p,
        target: i.current
      };
      fe(F, o, s), w(F);
    },
    [E, v, r.onChange, N, l, u, m]
  ), ge = t.useCallback(
    (e) => {
      if (!i.current)
        return;
      const o = {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        target: i.current
      };
      fe(o, null), w(o), e.preventDefault();
    },
    [E, r.onChange, l, u, m]
  ), be = t.useCallback(
    (e) => {
      if (e.syntheticEvent.stopPropagation(), r.onExpandChange && i.current) {
        const { item: o, itemHierarchicalIndex: s, nativeEvent: p, syntheticEvent: R } = e, F = {
          level: Re(s),
          item: o,
          nativeEvent: p,
          syntheticEvent: R,
          target: i.current
        };
        r.onExpandChange.call(void 0, F);
      }
    },
    [r.onExpandChange]
  ), he = t.useCallback(
    (e) => {
      if (r.onFilterChange && i.current) {
        const s = {
          filter: {
            field: r.textField,
            operator: "contains",
            value: e.target.value
          },
          syntheticEvent: e.syntheticEvent,
          nativeEvent: e.nativeEvent,
          target: i.current
        };
        r.onFilterChange.call(void 0, s), r.filter === void 0 && qe(e.target.value);
      }
    },
    [r.onFilterChange, r.filter, r.textField]
  ), Je = () => {
    const e = a.filterable ? /* @__PURE__ */ t.createElement(
      Me,
      {
        value: a.filter === void 0 ? ue : a.filter,
        ref: Y,
        onChange: he,
        onKeyDown: me,
        size: y,
        rounded: B,
        fillMode: W
      }
    ) : null, o = {
      title: a.adaptiveTitle,
      expand: l,
      onClose: (s) => w(s),
      windowWidth: ne,
      mobileFilter: e
    };
    return /* @__PURE__ */ t.createElement(Ct, { ...o }, /* @__PURE__ */ t.createElement(Et, { overflowHidden: !0 }, /* @__PURE__ */ t.createElement("div", { className: "k-list-container" }, /* @__PURE__ */ t.createElement("div", { className: "k-list k-list-lg" }, T.length > 0 ? /* @__PURE__ */ t.createElement(
      De,
      {
        ref: h,
        tabIndex: X,
        data: ye,
        focusIdField: N,
        textField: a.textField,
        selectField: z,
        expandField: a.expandField,
        childrenField: O,
        expandIcons: !0,
        onItemClick: ve,
        onExpandChange: be,
        size: y,
        item: a.item,
        dir: k,
        animate: b.animate
      }
    ) : /* @__PURE__ */ t.createElement(Ce, null, oe.toLanguageString(G, re[G]))))));
  }, Qe = t.useCallback((e) => {
    for (const o of e)
      We(o.target.clientWidth);
  }, []), ye = t.useMemo(() => E || !L ? T : it(
    T,
    O,
    (e) => lt(e, O, { [z]: Ie(e, v, N) })
  ), [T, v, E, L, z, O]), Ce = a.listNoData || vt, Xe = a.valueHolder || Ft, oe = ut(), Ee = !Ve || ee.valid, { size: y, rounded: B, fillMode: W } = a, ke = /* @__PURE__ */ t.createElement(t.Fragment, null, /* @__PURE__ */ t.createElement(
    "span",
    {
      className: ae("k-dropdowntree k-picker", a.className, {
        [`k-picker-${kt[y] || y}`]: y,
        [`k-rounded-${xt[B] || B}`]: B,
        [`k-picker-${W}`]: W,
        "k-focus": d,
        "k-invalid": !Ee,
        "k-loading": a.loading,
        "k-required": Q,
        "k-disabled": a.disabled
      }),
      tabIndex: X,
      accessKey: a.accessKey,
      id: le,
      style: K ? { ...P, width: void 0 } : P,
      dir: k,
      ref: f,
      onKeyDown: I ? void 0 : He,
      onMouseDown: Ue,
      onClick: I ? void 0 : ze,
      onFocus: je,
      onBlur: Ge,
      role: "combobox",
      "aria-haspopup": "tree",
      "aria-expanded": l,
      "aria-disabled": I,
      "aria-label": K,
      "aria-labelledby": a.ariaLabelledBy,
      "aria-describedby": a.ariaDescribedBy,
      "aria-required": Q
    },
    /* @__PURE__ */ t.createElement("span", { className: "k-input-inner" }, (Z || J) && /* @__PURE__ */ t.createElement(Xe, { item: v }, Z || J)),
    a.loading && /* @__PURE__ */ t.createElement(Fe, { className: "k-input-loading-icon", name: "loading" }),
    L && !I && /* @__PURE__ */ t.createElement(
      "span",
      {
        onClick: ge,
        className: "k-clear-value",
        title: oe.toLanguageString(Se, re[Se]),
        role: "button",
        tabIndex: -1,
        onMouseDown: (e) => e.preventDefault()
      },
      /* @__PURE__ */ t.createElement(Fe, { name: "x", icon: ht })
    ),
    /* @__PURE__ */ t.createElement(
      bt,
      {
        tabIndex: -1,
        type: "button",
        "aria-label": "select",
        className: "k-input-button",
        size: y,
        fillMode: W,
        themeColor: "base",
        rounded: null,
        icon: "caret-alt-down",
        svgIcon: yt
      }
    ),
    /* @__PURE__ */ t.createElement(
      "select",
      {
        name: Ne,
        ref: $,
        tabIndex: -1,
        "aria-hidden": !0,
        title: K,
        style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: "absolute", left: "50%" }
      },
      /* @__PURE__ */ t.createElement("option", { value: a.valueMap ? a.valueMap.call(void 0, v) : v })
    ),
    !x && /* @__PURE__ */ t.createElement(
      ct,
      {
        ...b,
        className: ae(b.className, { "k-rtl": k === "rtl" }),
        popupClass: ae(b.popupClass, "k-dropdowntree-popup k-list-container"),
        style: Le,
        anchor: b.anchor || f.current,
        show: l,
        onOpen: $e,
        onClose: _e
      },
      a.filterable && /* @__PURE__ */ t.createElement(
        Me,
        {
          value: a.filter === void 0 ? ue : a.filter,
          ref: S,
          onChange: he,
          onKeyDown: me,
          size: y,
          rounded: B,
          fillMode: W,
          renderListFilterWrapper: !0,
          renderPrefixSeparator: !0
        }
      ),
      T.length > 0 ? /* @__PURE__ */ t.createElement(
        De,
        {
          style: { height: b.height },
          ref: h,
          tabIndex: X,
          data: ye,
          focusIdField: N,
          textField: a.textField,
          selectField: z,
          expandField: a.expandField,
          childrenField: O,
          expandIcons: !0,
          onItemClick: ve,
          onExpandChange: be,
          size: y,
          item: a.item,
          dir: k,
          animate: b.animate
        }
      ) : /* @__PURE__ */ t.createElement(Ce, null, oe.toLanguageString(G, re[G]))
    )
  ), x && Je());
  return K ? /* @__PURE__ */ t.createElement(
    gt,
    {
      label: K,
      editorValue: Z,
      editorPlaceholder: J,
      editorValid: Ee,
      editorDisabled: I,
      editorId: le,
      style: { width: P ? P.width : void 0 },
      children: ke,
      dir: k
    }
  ) : ke;
}), St = {
  opened: n.bool,
  disabled: n.bool,
  dir: n.string,
  tabIndex: n.number,
  accessKey: n.string,
  data: n.array,
  value: n.any,
  valueMap: n.func,
  placeholder: n.string,
  dataItemKey: n.string.isRequired,
  textField: n.string.isRequired,
  selectField: n.string,
  expandField: n.string,
  subItemsField: n.string,
  className: n.string,
  style: n.object,
  label: n.string,
  validationMessage: n.string,
  validityStyles: n.bool,
  valid: n.bool,
  required: n.bool,
  name: n.string,
  id: n.string,
  ariaLabelledBy: n.string,
  ariaDescribedBy: n.string,
  filterable: n.bool,
  filter: n.string,
  loading: n.bool,
  popupSettings: n.shape({
    animate: n.oneOfType([
      n.bool,
      n.shape({
        openDuration: n.number,
        closeDuration: n.number
      })
    ]),
    popupClass: n.string,
    className: n.string,
    appendTo: n.any,
    width: n.oneOfType([n.string, n.number]),
    height: n.oneOfType([n.string, n.number])
  }),
  onOpen: n.func,
  onClose: n.func,
  onFocus: n.func,
  onBlur: n.func,
  onChange: n.func,
  onFilterChange: n.func,
  onExpandChange: n.func,
  item: n.func,
  valueHolder: n.func,
  listNoData: n.func,
  adaptiveTitle: n.string,
  adaptive: n.bool
};
Te.displayName = "KendoReactDropDownTree";
Te.propTypes = St;
export {
  Te as DropDownTree,
  It as DropDownTreePropsContext
};
