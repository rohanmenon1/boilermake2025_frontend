/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as i from "react";
import k from "prop-types";
import { validatePackage as Gt, useUnstyled as Yt, useId as $t, usePropsContext as jt, canUseDOM as rt, useAdaptiveModeContext as Jt, classNames as C, uDropDownList as b, getTabIndex as Qt, IconWrap as Xt, svgIconPropType as Zt, createPropsContext as Rt, Keys as w, uDropDownsActionSheet as J } from "@progress/kendo-react-common";
import { FloatingLabel as en } from "@progress/kendo-react-labels";
import { caretAltDownIcon as tn, xIcon as nn } from "@progress/kendo-svg-icons";
import rn from "../common/ListContainer.mjs";
import on from "../common/ListFilter.mjs";
import ot from "../common/GroupStickyHeader.mjs";
import an from "../common/ListDefaultItem.mjs";
import ln from "../common/List.mjs";
import dt from "../common/DropDownBase.mjs";
import { getFilteredData as P, areSame as N, getItemValue as fe, isPresent as it, itemIndexStartsWith as sn, sameCharsOnly as dn, shuffleData as cn, matchText as at } from "../common/utils.mjs";
import { packageMetadata as un } from "../package-metadata.mjs";
import { Button as lt } from "@progress/kendo-react-buttons";
import { useLocalization as pn } from "@progress/kendo-react-intl";
import { dropDownListArrowBtnAriaLabel as st, messages as mn } from "../messages/index.mjs";
import { ActionSheet as fn, ActionSheetHeader as vn, ActionSheetContent as gn } from "@progress/kendo-react-layout";
const hn = "Please select a value from the list!", Te = i.forwardRef((E, ct) => {
  Gt(un);
  const F = Yt(), ve = $t(E.id), r = jt(In, E), {
    delay: ut = z.delay,
    tabIndex: pt = z.tabIndex,
    ignoreCase: ge = z.ignoreCase,
    size: Q = z.size,
    rounded: ze = z.rounded,
    fillMode: he = z.fillMode,
    groupMode: yn = z.groupMode
  } = r, Ie = () => {
    var e;
    if (rt)
      return ((e = Z.current) == null ? void 0 : e.ownerDocument) || window.document;
  }, mt = () => {
    var e, n;
    (e = t == null ? void 0 : t.current) != null && e.wrapper && ((n = t == null ? void 0 : t.current) == null || n.wrapper.focus({ preventScroll: !0 }));
  }, L = () => {
    let e;
    return H.current !== void 0 && H.current !== null ? e = H.current : r.value !== void 0 ? e = r.value : p.value !== void 0 && p.value !== null ? e = p.value : r.defaultValue !== void 0 && r.defaultValue !== null && (e = r.defaultValue), !it(e) && r.defaultItem !== void 0 && r.defaultItem !== null && (e = r.defaultItem), e;
  }, ft = () => {
    const { dataItemKey: e } = r, n = P(E), a = L();
    return n.findIndex((c) => N(c, a, e));
  }, ye = () => r.required !== void 0 ? r.required : z.required, we = () => {
    const e = r.validationMessage !== void 0, n = L(), a = !ye() || n !== null && n !== "" && n !== void 0, c = r.valid !== void 0 ? r.valid : a;
    return {
      customError: e,
      valid: c,
      valueMissing: n === null
    };
  }, vt = () => r.validityStyles !== void 0 ? r.validityStyles : z.validityStyles, oe = (e) => {
    ie.current = !0, e.focus(), window.setTimeout(() => ie.current = !1, 30);
  }, xe = () => {
    R.current && oe(R.current), r.adaptive && setTimeout(() => {
      R.current && oe(R.current);
    }, 300);
  }, gt = i.useCallback((e) => {
    for (const n of e)
      Tt(n.target.clientWidth);
  }, []), Oe = () => {
    var e;
    (e = Ee.current) != null && e.setCustomValidity && Ee.current.setCustomValidity(
      we().valid ? "" : r.validationMessage || hn
    );
  }, q = (e, n) => {
    const a = L();
    N(a, e, r.dataItemKey) || (r.value === void 0 && (n.data.value = e), t.current.updateComponentArgs({ value: e }), H.current = e, n.events.push({ type: "onChange" }));
  }, K = (e) => {
    var n;
    (n = t == null ? void 0 : t.current) == null || n.applyState(e), H.current = void 0;
  }, X = (e, n) => {
    var s;
    const { virtual: a, dataItemKey: c, defaultItem: u } = r, m = P(E), v = a ? a.skip : 0, f = L(), o = e === -1 && u !== void 0 ? u : m[e - v], d = !N(o, f, c);
    q(o, n), d && ((s = t == null ? void 0 : t.current) == null || s.triggerPageChangeCornerItems(o, n));
  }, A = (e, n, a) => {
    var I, h;
    const { defaultItem: c, dataItemKey: u, virtual: m = { skip: 0, total: 0, pageSize: 0 } } = r, v = L(), f = P(E), o = (I = t == null ? void 0 : t.current) == null ? void 0 : I.vs, d = f.findIndex((y) => N(y, v, u)), s = (h = t == null ? void 0 : t.current) == null ? void 0 : h.navigation.navigate({
      current: m.skip + d,
      max: (o != null && o.enabled ? m.total : f.length) - 1,
      min: c !== void 0 ? -1 : 0,
      keyCode: n,
      skipItems: a || void 0
    });
    s !== void 0 && X(s, e), K(e);
  }, ht = (e) => {
    Z.current = e, t.current.wrapper = e;
  }, It = (e) => /* @__PURE__ */ i.createElement(
    "select",
    {
      name: r.name,
      ref: (n) => {
        Ee.current = n;
      },
      tabIndex: -1,
      "aria-hidden": !0,
      title: r.label,
      style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: "absolute", left: "50%" }
    },
    /* @__PURE__ */ i.createElement("option", { value: r.valueMap ? r.valueMap.call(void 0, e) : e })
  ), Se = () => {
    const {
      textField: e,
      dataItemKey: n,
      virtual: a = { skip: 0 },
      focusedItemIndex: c = sn,
      filterable: u,
      skipDisabledItems: m = !0
    } = r, v = L(), f = P(E), o = r.filter ? r.filter : p.text;
    return m && e && !o && !v ? f.findIndex((d) => !d.disabled && d[e]) : it(v) && o === void 0 || u && o === "" ? f.findIndex((d) => N(d, v, n)) : o ? ke.current ? c(f, o, e) : f.findIndex((d) => N(d, v, n)) : a.skip === 0 ? 0 : -1;
  }, Ae = (e, n) => n !== void 0 && n !== -1 && e && e.length > 0 && e[n].disabled, De = () => {
    const e = P(E), n = t.current.initState(), a = Se();
    Ae(e, a) && (q(null, n), K(n));
  }, Ce = (e) => {
    if (e.isPropagationStopped())
      return;
    const n = t.current.initState();
    n.syntheticEvent = e, p.focused || (n.data.focused = !0), De(), t.current.togglePopup(n), K(n);
  }, He = (e) => {
    var O, pe, _, me, j, tt, nt;
    e && e.target instanceof Element && e.target.nodeName === "INPUT" && e.stopPropagation && e.stopPropagation();
    const {
      filterable: n,
      disabled: a,
      defaultItem: c,
      leftRightKeysNavigation: u = !0,
      virtual: m = { skip: 0, total: 0, pageSize: 0 },
      dataItemKey: v,
      groupField: f = "",
      textField: o,
      skipDisabledItems: d = !0
    } = r, s = P(E), I = L(), h = s.findIndex((D) => N(D, I, v)), y = r.opened !== void 0 ? r.opened : p.opened, l = e.keyCode, T = l === w.home || l === w.end, M = l === w.up || l === w.down, $ = !y && (e.altKey && l === w.down || l === w.enter || l === w.space), re = y && (e.altKey && l === w.up || l === w.esc), ce = u && (l === w.left || l === w.right), ue = M || ce && !n || T, S = t.current.initState();
    if (S.syntheticEvent = e, !a) {
      if (T && ((O = t == null ? void 0 : t.current) != null && O.vs.enabled))
        l === w.home ? m.skip !== 0 ? ((pe = t == null ? void 0 : t.current) == null || pe.triggerOnPageChange(S, 0, m.pageSize), V.current = !0) : q(s[0], S) : m.skip < m.total - m.pageSize ? ((_ = t == null ? void 0 : t.current) == null || _.triggerOnPageChange(
          S,
          m.total - m.pageSize,
          m.pageSize
        ), V.current = !0) : q(s[s.length - 1], S);
      else if (y && l === w.pageUp)
        e.preventDefault(), (me = t == null ? void 0 : t.current) == null || me.scrollPopupByPageSize(-1);
      else if (y && l === w.pageDown)
        e.preventDefault(), (j = t == null ? void 0 : t.current) == null || j.scrollPopupByPageSize(1);
      else if (y && l === w.enter) {
        const D = Se();
        Ae(s, D) ? (q(null, S), K(S)) : X(D, S), (tt = t == null ? void 0 : t.current) == null || tt.togglePopup(S), e.preventDefault();
      } else if ($ || re)
        re && De(), (nt = t == null ? void 0 : t.current) == null || nt.togglePopup(S), e.preventDefault();
      else if (ue) {
        if (ke.current = !1, f !== "" && o)
          if (!d && y)
            A(S, l);
          else {
            let D;
            if (l === w.down || l === w.right) {
              const x = s.slice(h + 1).find((g) => !g.disabled && g[o]);
              D = x && s.findIndex((g) => g[o] === x[o]);
            } else if (l === w.up || l === w.left) {
              let x;
              if (h === 0 && c)
                D = -1;
              else if (h === -1)
                x = s, D = s.findIndex((g) => !g.disabled && g[o]);
              else {
                x = s.slice(0, h);
                let g = x.pop();
                for (; g && g.disabled; )
                  g = x.pop();
                D = g && s.findIndex((Ke) => Ke[o] === g[o]);
              }
            }
            if (D !== void 0) {
              const x = D - h;
              A(S, l, x);
            } else
              D === void 0 && s.findIndex((x) => x[o] === I[o]) === s.length - 1 && A(S, l);
          }
        else if (!d && y || T)
          A(S, l);
        else if (o) {
          let D;
          if (l === w.down || l === w.right) {
            const x = s.slice(h + 1).find((g) => !g.disabled && g[o]);
            D = x && s.findIndex((g) => g[o] === x[o]);
          } else if (l === w.up || l === w.left) {
            let x;
            if (h === 0 && c)
              D = -1;
            else if (h === -1)
              x = s, D = s.find((g) => !g.disabled && g[o]);
            else {
              x = s.slice(0, h);
              let g = x.pop();
              for (; g && g.disabled; )
                g = x.pop();
              D = g && s.findIndex((Ke) => Ke[o] === g[o]);
            }
          }
          if (D !== void 0) {
            const x = D - h;
            A(S, l, x);
          } else
            D === void 0 && s.findIndex((x) => x[o] === I[o]) === s.length - 1 && A(S, l);
        } else
          A(S, l);
        e.preventDefault();
      }
      K(S);
    }
  }, yt = (e) => {
    const n = t.current.initState();
    n.syntheticEvent = e.syntheticEvent, r.filter === void 0 && (n.data.text = e.target.value), t.current.filterChanged(e.target.value, n), ke.current = !0, K(n), te({ group: void 0, text: String(e.target.value) });
  }, Ve = () => {
    const e = r.filter !== void 0 ? r.filter : p.text;
    return r.filterable && /* @__PURE__ */ i.createElement(
      on,
      {
        value: e,
        ref: (n) => R.current = n && n.element,
        onChange: yt,
        onKeyDown: He,
        size: Q,
        rounded: ze,
        fillMode: he,
        renderListFilterWrapper: !0
      }
    );
  }, wt = (e) => {
    var a;
    const n = t.current.initState();
    n.syntheticEvent = e, (a = t == null ? void 0 : t.current) == null || a.togglePopup(n), q(r.defaultItem, n), K(n);
  }, Be = () => {
    const { textField: e, defaultItem: n, dataItemKey: a } = r, c = L();
    return n !== void 0 && /* @__PURE__ */ i.createElement(
      an,
      {
        defaultItem: n,
        textField: e,
        selected: N(c, n, a),
        key: "defaultitemkey",
        onClick: wt
      }
    );
  }, xt = (e, n) => {
    var a;
    (a = t == null ? void 0 : t.current) == null || a.handleItemClick(e, n), H.current = void 0;
  }, St = (e) => {
    const { vs: n, list: a } = t.current;
    n.scrollHandler(e);
    const { groupField: c } = r;
    let u = P(E);
    if (!(!c || !u.length) && c) {
      const m = Ue.current = Ue.current || (n.enabled ? n.itemHeight : a ? a.children[0].offsetHeight : 0), f = e.target.scrollTop - n.skip * m;
      u = t.current.getGroupedDataModernMode(u, c);
      let o = u[0][c];
      for (let d = 1; d < u.length && !(m * d > f); d++)
        u[d] && u[d][c] && (o = u[d][c]);
      o !== p.group && te({ group: o });
    }
  }, We = () => {
    var l;
    const {
      textField: e,
      dataItemKey: n,
      virtual: a = { skip: 0, total: void 0 },
      groupHeaderItemRender: c,
      listNoDataRender: u,
      itemRender: m
    } = r, v = P(E), f = F && F.uDropDownList, o = t.current.vs, d = a.skip, s = r.opened !== void 0 ? r.opened : p.opened, I = t.current.getPopupSettings(), h = `translateY(${o.translate}px)`, y = L();
    return /* @__PURE__ */ i.createElement(
      ln,
      {
        id: be,
        show: s,
        data: v.slice(),
        focusedIndex: Se(),
        value: y,
        textField: e,
        valueField: n,
        optionsGuid: $e,
        groupField: r.groupField,
        groupMode: "modern",
        listRef: (T) => o.list = t.current.list = T,
        wrapperStyle: { maxHeight: I.height },
        wrapperCssClass: C(b.listContent({ c: f })),
        listStyle: o.enabled ? { transform: h } : void 0,
        key: "listkey",
        skip: d,
        onClick: xt,
        itemRender: m,
        groupHeaderItemRender: c,
        noDataRender: u,
        onScroll: St,
        wrapperRef: o.scrollerRef,
        scroller: (l = t == null ? void 0 : t.current) == null ? void 0 : l.renderScrollElement(),
        ariaSetSize: a.total
      }
    );
  }, Dt = () => {
    var h;
    const { header: e, footer: n, adaptiveTitle: a, groupField: c, groupStickyHeaderItemRender: u, list: m } = r, v = P(E), f = r.opened !== void 0 ? r.opened : p.opened, o = F && F.uDropDownList, d = F && F.uDropDownsActionSheet, s = {
      navigatable: !1,
      navigatableElements: [],
      expand: f,
      animation: !0,
      onClose: (y) => Ce(y),
      className: C(
        J.wrapper({
          c: d
        }),
        "k-adaptive-actionsheet"
      ),
      animationStyles: G && Y && G <= Y.small ? { top: 0, width: "100%", height: "100%" } : void 0,
      position: G && Y && G <= Y.small ? "fullscreen" : void 0
    };
    let { group: I } = p;
    return I === void 0 && c !== void 0 && (I = fe(v[0], c)), /* @__PURE__ */ i.createElement(fn, { ...s }, /* @__PURE__ */ i.createElement(vn, { className: C(J.header({ c: d })) }, /* @__PURE__ */ i.createElement("div", { className: C(J.titleBar({ c: d })) }, /* @__PURE__ */ i.createElement("div", { className: C(J.title({ c: d })) }, /* @__PURE__ */ i.createElement("div", null, a)), /* @__PURE__ */ i.createElement("div", { className: C(J.actions({ c: d })) }, /* @__PURE__ */ i.createElement(
      lt,
      {
        tabIndex: 0,
        "aria-label": "Cancel",
        "aria-disabled": "false",
        type: "button",
        fillMode: "flat",
        onClick: Ce,
        icon: "x",
        svgIcon: nn
      }
    ))), /* @__PURE__ */ i.createElement("div", { className: C(J.titleBarGroup({ c: d })) }, Ve())), /* @__PURE__ */ i.createElement(gn, { overflowHidden: !0 }, e && /* @__PURE__ */ i.createElement("div", { className: C(b.listHeader({ c: o })) }, e), /* @__PURE__ */ i.createElement(
      "div",
      {
        className: C(
          b.list({
            c: o,
            size: Q,
            virtual: (h = t == null ? void 0 : t.current) == null ? void 0 : h.vs.enabled
          })
        )
      },
      Be(),
      !m && I && v.length !== 0 && /* @__PURE__ */ i.createElement(
        ot,
        {
          group: I,
          groupMode: "modern",
          render: u
        }
      ),
      We()
    ), n && /* @__PURE__ */ i.createElement("div", { className: C(b.listFooter({ c: o })) }, n)));
  }, Ct = () => {
    p.focused && window.setTimeout(() => {
      p.focused && t.current.wrapper && oe(t.current.wrapper);
    });
  }, Et = (e) => {
    var n;
    (n = r.popupSettings) != null && n.onMouseDownOutside && r.popupSettings.onMouseDownOutside.call(void 0, e);
  }, kt = () => {
    const { header: e, footer: n, dir: a, groupField: c, groupStickyHeaderItemRender: u, list: m } = r, v = P(E), f = t.current, o = f.getPopupSettings(), d = r.opened !== void 0 ? r.opened : p.opened, s = o.width !== void 0 ? o.width : f.popupWidth, I = F && F.uDropDownList, h = {
      dir: a !== void 0 ? a : f.dirCalculated,
      width: s,
      popupSettings: {
        ...o,
        popupClass: C(
          o.popupClass,
          b.listContainer({
            c: I
          })
        ),
        anchor: o.anchor || Z.current,
        show: d,
        onOpen: xe,
        onClose: Ct,
        onMouseDownOutside: Et
      },
      itemsCount: [v.length]
    };
    let { group: y } = p;
    return y === void 0 && c !== void 0 && (y = fe(v[0], c)), /* @__PURE__ */ i.createElement(rn, { ...h }, Ve(), e && /* @__PURE__ */ i.createElement("div", { className: C(b.listHeader({ c: I })) }, e), /* @__PURE__ */ i.createElement(
      "div",
      {
        className: C(
          b.list({
            c: I,
            size: Q,
            virtual: t.current.vs.enabled
          })
        )
      },
      Be(),
      !m && y && v.length !== 0 && /* @__PURE__ */ i.createElement(ot, { group: y, groupMode: "modern", render: u }),
      We()
    ), n && /* @__PURE__ */ i.createElement("div", { className: C(b.listFooter({ c: I })) }, n));
  }, Lt = (e) => {
    const { dataItemKey: n } = r, a = P(E), c = L();
    let u = a.map((M, $) => ({ item: M, itemIndex: $ }));
    const m = U.current.word, v = U.current.last, f = dn(m, v);
    let o = u.length, d = Math.max(
      0,
      a.findIndex((M) => N(M, c, n))
    ), s;
    r.defaultItem && (s = { item: r.defaultItem, itemIndex: -1 }, o += 1, d += 1), d += f ? 1 : 0, u = cn(u, d, s);
    let I, h, y, l = 0;
    const { textField: T } = r;
    for (; l < o; ) {
      if (I = fe(u[l].item, T), h = f && at(I, v, ge), y = at(I, m, ge), h || y) {
        l = u[l].itemIndex;
        break;
      }
      l++;
    }
    if (l !== o) {
      const M = t.current.initState();
      M.syntheticEvent = e, X(l, M), K(M), H.current = void 0;
    }
  }, bt = (e) => {
    clearTimeout(qe.current), r.filterable || (qe.current = window.setTimeout(() => U.current.word = "", ut), Lt(e));
  }, Pt = (e) => {
    ie.current || t.current.handleFocus(e);
  }, Mt = (e) => {
    if (ie.current || !p.focused)
      return;
    const n = r.opened !== void 0 ? r.opened : p.opened, a = t.current.initState();
    a.syntheticEvent = e, a.data.focused = !1, a.events.push({ type: "onBlur" }), n && De(), n && !Fe && t.current.togglePopup(a), K(a);
  }, Nt = (e) => {
    if (r.filterable || e.which === 0 || e.keyCode === w.enter)
      return;
    let n = String.fromCharCode(e.charCode || e.keyCode);
    ge && (n = n.toLowerCase()), n === " " && e.preventDefault(), U.current = {
      word: U.current.word + n,
      last: U.current.last + n
    }, bt(e);
  }, Ft = () => {
    const e = t.current.initState();
    e.data.opened = p.opened, t.current.togglePopup(e), K(e);
  }, _e = i.useRef(null), Z = i.useRef(null), Ee = i.useRef(), R = i.useRef(null);
  i.useImperativeHandle(
    _e,
    () => ({
      get element() {
        return Z.current;
      },
      get index() {
        return ft();
      },
      get name() {
        return r.name;
      },
      get validity() {
        return we();
      },
      get value() {
        return L();
      },
      get focused() {
        return p.focused;
      },
      get opened() {
        return p.opened;
      },
      focus: mt,
      props: r,
      togglePopup: Ft
    })
  ), i.useImperativeHandle(
    ct,
    () => _e.current
  );
  const qe = i.useRef(null), U = i.useRef({ word: "", last: "" }), ie = i.useRef(!1), H = i.useRef(null), V = i.useRef(!1), ke = i.useRef(!1), B = i.useRef({}), Le = i.useRef({}), t = i.useRef(
    new dt({
      props: E,
      setState: () => {
      },
      state: {},
      forceUpdate: () => {
      },
      element: null,
      value: null,
      handleItemSelect: () => {
      }
    })
  ), Ue = i.useRef(0), ee = i.useRef(null), [p, Kt] = i.useState({}), [G, Tt] = i.useState(), [, Ge] = i.useReducer((e) => e, !0), zt = pn(), te = (e) => {
    Kt({ ...p, ...e });
  };
  i.useEffect(() => {
    t.current.updateComponentArgs({
      props: E,
      setState: te,
      state: p,
      forceUpdate: Ge,
      element: Z.current,
      handleItemSelect: X,
      value: L()
    });
  }, [te, p, Ge, X, L]), i.useEffect(() => {
    var d, s, I, h, y, l, T, M, $, re, ce, ue, S;
    const { dataItemKey: e, virtual: n, groupField: a = "", textField: c } = r, u = P(E), m = B.current.virtual ? B.current.virtual.total : 0, v = r.opened !== void 0 ? r.opened : p.opened, f = B.current.opened !== void 0 ? B.current.opened : Le.current.opened, o = !f && v;
    if ((d = t == null ? void 0 : t.current) == null || d.didUpdate(), (s = t == null ? void 0 : t.current) != null && s.getPopupSettings().animate || o && xe(), n && n.total !== m)
      (I = t == null ? void 0 : t.current) == null || I.vs.calcScrollElementHeight(), (h = t == null ? void 0 : t.current) == null || h.vs.reset();
    else {
      const O = L(), pe = B.current.value !== void 0 ? B.current.value : Le.current.value;
      let _ = u.findIndex((j) => N(j, O, e));
      a !== "" && O && c && (_ = (l = (y = t == null ? void 0 : t.current) == null ? void 0 : y.getGroupedDataModernMode(u, a)) == null ? void 0 : l.map((j) => j[c]).indexOf(O[c]));
      const me = !N(pe, O, e);
      o && n ? (T = t == null ? void 0 : t.current) == null || T.scrollToVirtualItem(n, _) : o && !n ? (xe(), u && u.length !== 0 && ((M = t == null ? void 0 : t.current) == null || M.resetGroupStickyHeader(u[0][a], {
        setState: te,
        group: p.group,
        state: p
      })), ($ = t == null ? void 0 : t.current) == null || $.scrollToItem(_)) : v && f && O && me && !V.current ? (ce = t == null ? void 0 : t.current) == null || ce.scrollToItem(_, (re = t == null ? void 0 : t.current) == null ? void 0 : re.vs.enabled) : v && f && V.current && (V.current && n && n.skip === 0 ? (ue = t == null ? void 0 : t.current) == null || ue.vs.reset() : V.current && n && n.skip === n.total - n.pageSize && ((S = t == null ? void 0 : t.current) == null || S.vs.scrollToEnd()));
    }
    V.current = !1, Le.current = p, B.current = r, Oe();
  }), i.useEffect(() => {
    var e, n;
    return ee.current = rt && window.ResizeObserver && new window.ResizeObserver(gt.bind(void 0)), (e = t == null ? void 0 : t.current) == null || e.didMount(), Oe(), (n = Ie()) != null && n.body && ee.current && ee.current.observe(Ie().body), () => {
      var a;
      (a = Ie()) != null && a.body && ee.current && ee.current.disconnect();
    };
  }, []);
  const Ye = ve + "-accessibility-id", be = ve + "-listbox-id", $e = ve + "-guid", Ot = zt.toLanguageString(
    st,
    mn[st]
  ), {
    style: ae,
    className: At,
    label: Pe,
    dir: Ht,
    virtual: W,
    adaptive: wn,
    dataItemKey: Vt,
    disabled: le,
    loading: je,
    iconClassName: Je,
    svgIcon: Qe,
    valueRender: Xe
  } = r, Me = r.opened !== void 0 ? r.opened : p.opened, se = L(), Ne = fe(se, r.textField), Ze = !vt() || we().valid, de = t.current, Bt = de.vs, ne = F && F.uDropDownList;
  Bt.enabled = W !== void 0;
  const Y = Jt(), Fe = !!(G && Y && G <= Y.medium && E.adaptive);
  W !== void 0 && (de.vs.skip = W.skip, de.vs.total = W.total, de.vs.pageSize = W.pageSize);
  const Wt = P(E), { focused: _t } = p, qt = Wt.findIndex((e) => N(e, se, Vt)), Re = /* @__PURE__ */ i.createElement("span", { id: Ye, className: C(b.inputInner({ c: ne })) }, Ne && /* @__PURE__ */ i.createElement("span", { className: C(b.inputText({ c: ne })) }, Ne)), Ut = Xe !== void 0 ? Xe.call(void 0, Re, se) : Re, et = /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    "span",
    {
      ref: ht,
      className: C(
        b.wrapper({
          c: ne,
          size: Q,
          rounded: ze,
          fillMode: he,
          focused: _t,
          disabled: le,
          invalid: !Ze,
          loading: je,
          required: ye()
        }),
        At
      ),
      style: Pe ? { ...ae, width: void 0 } : ae,
      dir: Ht,
      onMouseDown: Me ? (e) => {
        e.target.nodeName !== "INPUT" && (oe(t.current.wrapper), e.preventDefault());
      } : void 0,
      onFocus: Pt,
      onBlur: Mt,
      tabIndex: Qt(pt, le),
      accessKey: r.accessKey,
      onKeyDown: He,
      onKeyPress: Nt,
      onClick: le ? void 0 : Ce,
      role: "combobox",
      "aria-required": ye(),
      "aria-disabled": le || void 0,
      "aria-haspopup": "listbox",
      "aria-expanded": Me || !1,
      "aria-owns": be,
      "aria-activedescendant": Me ? "option-" + $e + "-" + (qt + (W ? W.skip : 0)) : void 0,
      "aria-label": r.ariaLabel || r.label,
      "aria-labelledby": r.ariaLabelledBy,
      "aria-describedby": r.ariaDescribedBy || Ye,
      "aria-controls": be,
      id: r.id,
      title: r.title
    },
    Ut,
    je && /* @__PURE__ */ i.createElement(Xt, { className: C(b.loadingIcon({ c: ne })), name: "loading" }),
    /* @__PURE__ */ i.createElement(
      lt,
      {
        tabIndex: -1,
        type: "button",
        "aria-label": Ot,
        size: Q,
        fillMode: he,
        iconClass: Je,
        className: C(b.inputButton({ c: ne })),
        rounded: null,
        themeColor: "base",
        icon: Je ? void 0 : "caret-alt-down",
        svgIcon: Qe || tn,
        onMouseDown: (e) => p.focused && e.preventDefault()
      }
    ),
    It(se),
    !Fe && kt()
  ), Fe && Dt());
  return Pe ? /* @__PURE__ */ i.createElement(
    en,
    {
      label: Pe,
      editorValue: Ne,
      editorValid: Ze,
      editorDisabled: r.disabled,
      style: { width: ae ? ae.width : void 0 },
      children: et
    }
  ) : et;
});
Te.propTypes = {
  delay: k.number,
  ignoreCase: k.bool,
  iconClassName: k.string,
  svgIcon: Zt,
  defaultItem: k.any,
  valueRender: k.func,
  valueMap: k.func,
  validationMessage: k.string,
  required: k.bool,
  id: k.string,
  ariaLabelledBy: k.string,
  ariaDescribedBy: k.string,
  ariaLabel: k.string,
  leftRightKeysNavigation: k.bool,
  title: k.string,
  groupField: k.string,
  list: k.any,
  skipDisabledItems: k.bool
};
const z = {
  delay: 500,
  tabIndex: 0,
  ignoreCase: !0,
  ...dt.defaultProps,
  required: !1,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  groupMode: "modern"
};
Te.displayName = "KendoReactDropDownList";
const In = Rt();
Te.displayName = "KendoReactDropDownList";
export {
  Te as DropDownList,
  In as DropDownListPropsContext,
  z as dropDownListDefaultProps
};
