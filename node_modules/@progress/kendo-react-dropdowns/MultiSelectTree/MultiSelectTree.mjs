/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import n from "prop-types";
import { createPropsContext as it, usePropsContext as rt, validatePackage as ot, useId as lt, getTabIndex as st, useRtl as ct, useAdaptiveModeContext as ut, canUseDOM as dt, noop as Z, Keys as o, classNames as ee, IconWrap as pt, kendoThemeMaps as ft } from "@progress/kendo-react-common";
import { Popup as mt } from "@progress/kendo-react-popup";
import { useLocalization as gt } from "@progress/kendo-react-intl";
import { TreeView as Te } from "@progress/kendo-react-treeview";
import { packageMetadata as vt } from "../package-metadata.mjs";
import { getItemValue as ht, areSame as bt, matchTags as De } from "../common/utils.mjs";
import { useDropdownWidth as yt } from "../DropDownTree/useDropdownWidth.mjs";
import { ListNoData as Ct } from "../DropDownTree/ListNoData.mjs";
import { nodata as te, messages as ne, adaptiveModeFooterCancel as Re, adaptiveModeFooterApply as Me } from "../messages/index.mjs";
import { FloatingLabel as Et } from "@progress/kendo-react-labels";
import kt from "../MultiSelect/TagList.mjs";
import Ft from "../common/ClearButton.mjs";
import Ne from "../common/ListFilter.mjs";
import { AdaptiveMode as xt } from "../common/AdaptiveMode.mjs";
import { ActionSheetContent as St } from "@progress/kendo-react-layout";
const wt = "Please select a value from the list!", { sizeMap: Pe, roundedMap: It } = ft, Tt = (O) => O.split("_").map((R) => parseInt(R, 10)), Dt = (O, R) => {
  const { validationMessage: a, valid: V, required: x } = O;
  return {
    customError: a !== void 0,
    valid: !!(V !== void 0 ? V : !x || R),
    valueMissing: !R
  };
}, y = {
  checkField: "checkField",
  checkIndeterminateField: "checkIndeterminateField",
  subItemsField: "items",
  popupSettings: {
    animate: !0,
    width: "200px",
    height: "200px"
  },
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  required: !1,
  validityStyles: !0
}, Rt = it(), Oe = t.forwardRef(
  (O, R) => {
    const a = rt(Rt, O);
    ot(vt);
    const V = lt(), x = a.id || V, {
      data: q = [],
      dataItemKey: S,
      style: L = {},
      placeholder: de,
      label: B,
      name: Le,
      validationMessage: A,
      valid: Be,
      tags: pe,
      value: m,
      opened: w,
      disabled: E,
      popupSettings: M = y.popupSettings,
      checkField: fe = y.checkField,
      checkIndeterminateField: me = y.checkIndeterminateField,
      subItemsField: ge = y.subItemsField,
      size: v = y.size,
      rounded: K = y.rounded,
      fillMode: W = y.fillMode,
      required: ve = y.required,
      validityStyles: Ke = y.validityStyles,
      onOpen: ae = Z,
      onClose: z = Z
    } = a, H = st(a.tabIndex, E), l = t.useRef(null), C = t.useRef(null), I = t.useRef(null), ie = t.useRef(null), $ = t.useRef(null), k = t.useRef(null), G = t.useRef(!1), _ = t.useRef([]), j = t.useRef(null), [N, Ve] = t.useState(), [qe, he] = t.useState(!1), [d, re] = t.useState(!1), [oe, Ae] = t.useState(), [We, ze] = t.useState([]), [be, He] = t.useState(""), s = w !== void 0 ? w : qe, le = !!(Array.isArray(m) && m.length), se = Dt({ validationMessage: A, valid: Be, required: ve }, le), T = ct(C, a.dir), $e = {
      width: yt(C, y, M, L),
      ...T !== void 0 ? { direction: T } : {}
    }, Ge = t.useCallback(() => C.current && C.current.focus(), []), ye = ut(), P = !!(oe && ye && oe <= ye.medium && a.adaptive);
    _.current = pe === void 0 ? (m || []).map((e) => ({ text: ht(e, a.textField), data: [e] })) : [...pe], t.useImperativeHandle(l, () => ({
      props: a,
      element: C.current,
      focus: Ge
    })), t.useImperativeHandle(
      R,
      () => l.current
    );
    const _e = t.useCallback(() => {
      $.current && $.current.setCustomValidity && $.current.setCustomValidity(
        se.valid ? "" : A === void 0 ? wt : A
      );
    }, [A, se]);
    t.useEffect(_e), t.useEffect(() => {
      const e = dt && window.ResizeObserver && new window.ResizeObserver(nt.bind(void 0));
      return document != null && document.body && e && e.observe(document.body), () => {
        e && e.disconnect();
      };
    }, []), t.useEffect(() => {
      j.current && s && j.current.setPosition(j.current.element);
    }, [m, s]);
    const F = t.useCallback(
      (e, i, r) => {
        if (a.onChange) {
          const b = {
            items: i,
            operation: r,
            ...e
          };
          a.onChange.call(void 0, b);
        }
      },
      [a.onChange]
    ), U = t.useCallback(
      (e) => {
        if (bt(e.item, m, S) || !l.current)
          return;
        const { item: i, nativeEvent: r, syntheticEvent: b } = e, D = {
          syntheticEvent: b,
          nativeEvent: r,
          target: l.current
        };
        F(D, [i], "toggle");
      },
      [m, S, F]
    ), J = t.useCallback(
      (e) => {
        if (!s) {
          if (ae) {
            const i = { ...e };
            ae.call(void 0, i);
          }
          w === void 0 && (he(!0), ze(m || []), P && setTimeout(() => {
            var i;
            u((i = ie.current) == null ? void 0 : i.element);
          }, 300));
        }
      },
      [s, w, ae, P, ie]
    ), g = t.useCallback(
      (e) => {
        if (s) {
          if (z) {
            const i = { ...e };
            z.call(void 0, i);
          }
          w === void 0 && he(!1);
        }
      },
      [s, w, z]
    ), h = t.useCallback((e) => {
      G.current = !0, e(), window.setTimeout(() => G.current = !1, 0);
    }, []), u = t.useCallback(
      (e) => {
        e && h(() => e.focus());
      },
      [h]
    ), je = t.useCallback(() => {
      var e;
      !d && s ? g({ target: l.current }) : a.filterable ? u((e = I.current) == null ? void 0 : e.element) : u(k.current && k.current.element);
    }, [d, s, u, g, a.filterable]), Ue = t.useCallback(() => {
      d && u(C.current);
    }, [d, u]), Je = t.useCallback(
      (e) => {
        if (!d && !G.current && (re(!0), a.onFocus && l.current)) {
          const i = {
            syntheticEvent: e,
            nativeEvent: e.nativeEvent,
            target: l.current
          };
          a.onFocus.call(void 0, i);
        }
      },
      [d, a.onFocus]
    ), Qe = t.useCallback(
      (e) => {
        if (d && !G.current && l.current) {
          re(!1);
          const i = {
            syntheticEvent: e,
            nativeEvent: e.nativeEvent,
            target: l.current
          };
          if (a.onBlur) {
            const r = { ...i };
            a.onBlur.call(void 0, r);
          }
          P || g(i);
        }
      },
      [d, a.onBlur, s, w, z]
    ), Xe = t.useCallback(() => {
      d && h(Z);
    }, [d, h]), Ye = t.useCallback(
      (e) => {
        if (!e.isDefaultPrevented() && l.current) {
          re(!0);
          const i = {
            syntheticEvent: e,
            nativeEvent: e.nativeEvent,
            target: l.current
          };
          s || J(i);
        }
      },
      [s, J]
    ), Ze = t.useCallback(
      (e) => {
        var Y, Ie;
        const { keyCode: i, altKey: r } = e, b = k.current && k.current.element;
        if (!l.current || e.isDefaultPrevented() && ((Y = I.current) == null ? void 0 : Y.element) === e.target)
          return;
        const D = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: l.current
        };
        if (m && m.length > 0 && (i === o.left || i === o.right || i === o.home || i === o.end || i === o.delete)) {
          const c = _.current;
          let p = N ? c.findIndex((at) => De(at, N, S)) : -1, f;
          const ue = p !== -1;
          i === o.left ? (ue ? p = Math.max(0, p - 1) : p = c.length - 1, f = c[p]) : i === o.right ? p === c.length - 1 ? f = void 0 : ue && (p = Math.min(c.length - 1, p + 1), f = c[p]) : i === o.home ? f = c[0] : i === o.end ? f = c[c.length - 1] : i === o.delete && ue && F(D, c[p].data, "delete"), f !== N && Ve(f);
        }
        if (s)
          if (i === o.esc || r && i === o.up)
            e.preventDefault(), g(D);
          else if (b && b.querySelector(".k-focus") && (i === o.up || i === o.down || i === o.left || i === o.right || i === o.home || i === o.end)) {
            if (i === o.up && ((Ie = I.current) != null && Ie.element)) {
              const c = Array.from(b.querySelectorAll(".k-treeview-item")), p = [...c].reverse().find((f) => !!(f && f.querySelector(".k-focus")));
              if (p && c.indexOf(p) === 0)
                return h(() => {
                  var f;
                  u((f = I.current) == null ? void 0 : f.element);
                });
            }
            h(Z);
          } else
            i === o.down && h(() => {
              var c;
              u(((c = I.current) == null ? void 0 : c.element) || b);
            });
        else
          r && i === o.down && (e.preventDefault(), J(D));
      },
      [s, g, u, h, J, N, S, m, F]
    ), Ce = t.useCallback(
      (e) => {
        const { keyCode: i, altKey: r } = e;
        r || i !== o.up && i !== o.down || (e.preventDefault(), h(
          i === o.up ? () => {
            u(C.current);
          } : () => {
            u(k.current && k.current.element);
          }
        ));
      },
      [u, h]
    ), ce = t.useCallback(
      (e) => {
        if (!l.current)
          return;
        const i = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: l.current
        };
        F(i, [], "clear"), g(i), e.preventDefault();
      },
      [F, g]
    ), et = t.useCallback(
      (e, i) => {
        var r;
        g({ target: l.current }), d || u((r = I.current) == null ? void 0 : r.element), F(
          {
            syntheticEvent: i,
            nativeEvent: i.nativeEvent,
            target: l.current
          },
          e,
          "delete"
        );
      },
      [F, g, u, d]
    ), Ee = t.useCallback(
      (e) => {
        if (a.onExpandChange && l.current) {
          const { item: i, itemHierarchicalIndex: r, nativeEvent: b, syntheticEvent: D } = e, Y = {
            level: Tt(r),
            item: i,
            nativeEvent: b,
            syntheticEvent: D,
            target: l.current
          };
          a.onExpandChange.call(void 0, Y);
        }
      },
      [a.onExpandChange]
    ), ke = t.useCallback(
      (e) => {
        if (a.onFilterChange && l.current) {
          const r = {
            filter: {
              field: a.textField,
              operator: "contains",
              value: e.target.value
            },
            syntheticEvent: e.syntheticEvent,
            nativeEvent: e.nativeEvent,
            target: l.current
          };
          a.onFilterChange.call(void 0, r), a.filter === void 0 && He(e.target.value);
        }
      },
      [a.onFilterChange, a.filter, a.textField]
    ), Fe = t.useCallback(
      (e) => {
        if (!l.current)
          return;
        const i = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: l.current
        };
        a.onCancel && a.onCancel.call(void 0, i), g(i), e.preventDefault();
      },
      [a.onCancel, g]
    ), tt = () => {
      const e = a.filterable ? /* @__PURE__ */ t.createElement(
        Ne,
        {
          value: a.filter === void 0 ? be : a.filter,
          ref: ie,
          onChange: ke,
          onKeyDown: Ce,
          size: v,
          rounded: K,
          fillMode: W
        }
      ) : null, i = {
        title: a.adaptiveTitle,
        expand: s,
        onClose: (r) => a.onCancel ? Fe(r) : ce(r),
        windowWidth: oe,
        mobileFilter: e,
        footer: {
          cancelText: Q.toLanguageString(
            Re,
            ne[Re]
          ),
          onCancel: (r) => a.onCancel ? Fe(r) : ce(r),
          applyText: Q.toLanguageString(
            Me,
            ne[Me]
          ),
          onApply: (r) => g(r)
        }
      };
      return /* @__PURE__ */ t.createElement(xt, { ...i }, /* @__PURE__ */ t.createElement(St, { overflowHidden: !0 }, /* @__PURE__ */ t.createElement("div", { className: "k-list-container" }, /* @__PURE__ */ t.createElement("div", { className: "k-list k-list-lg" }, q.length > 0 ? /* @__PURE__ */ t.createElement(
        Te,
        {
          ref: k,
          tabIndex: H,
          data: q,
          focusIdField: S,
          textField: a.textField,
          checkField: fe,
          checkIndeterminateField: me,
          expandField: a.expandField,
          childrenField: ge,
          expandIcons: !0,
          onItemClick: U,
          onCheckChange: U,
          onExpandChange: Ee,
          checkboxes: !0,
          size: v,
          item: a.item,
          dir: T
        }
      ) : /* @__PURE__ */ t.createElement(xe, null, Q.toLanguageString(te, ne[te]))))));
    }, nt = t.useCallback((e) => {
      for (const i of e)
        Ae(i.target.clientWidth);
    }, []), xe = a.listNoData || Ct, Q = gt(), Se = !Ke || se.valid, X = P && s ? We : _.current, we = /* @__PURE__ */ t.createElement(t.Fragment, null, /* @__PURE__ */ t.createElement(
      "span",
      {
        className: ee("k-multiselecttree k-input", a.className, {
          [`k-input-${Pe[v] || v}`]: v,
          [`k-rounded-${It[K] || K}`]: K,
          [`k-input-${W}`]: W,
          "k-focus": d && !E,
          "k-invalid": !Se,
          "k-disabled": E,
          "k-loading": a.loading,
          "k-required": ve
        }),
        tabIndex: H,
        accessKey: a.accessKey,
        id: x,
        style: B ? { ...L, width: void 0 } : L,
        dir: T,
        ref: C,
        onKeyDown: E ? void 0 : Ze,
        onMouseDown: Xe,
        onFocus: Je,
        onBlur: Qe,
        role: "combobox",
        "aria-haspopup": "tree",
        "aria-expanded": s,
        "aria-disabled": E,
        "aria-label": B,
        "aria-labelledby": a.ariaLabelledBy,
        "aria-describedby": a.ariaDescribedBy ? a.ariaDescribedBy : "tagslist-" + x,
        "aria-required": a.required,
        onClick: E ? void 0 : Ye
      },
      /* @__PURE__ */ t.createElement(
        "div",
        {
          id: "tagslist-" + x,
          className: ee("k-input-values k-chip-list", {
            [`k-chip-list-${Pe[v] || v}`]: v
          })
        },
        X.length > 0 && /* @__PURE__ */ t.createElement(
          kt,
          {
            tag: a.tag,
            onTagDelete: et,
            data: X,
            guid: x,
            focused: N ? _.current.find(
              (e) => De(e, N, S)
            ) : void 0,
            size: v
          }
        )
      ),
      /* @__PURE__ */ t.createElement("span", { className: "k-input-inner" }, X.length === 0 && /* @__PURE__ */ t.createElement("span", { className: "k-input-value-text" }, de)),
      a.loading && /* @__PURE__ */ t.createElement(pt, { className: "k-input-loading-icon", name: "loading" }),
      le && !E && X.length > 0 && /* @__PURE__ */ t.createElement(Ft, { onClick: ce }),
      /* @__PURE__ */ t.createElement(
        "select",
        {
          name: Le,
          ref: $,
          tabIndex: -1,
          "aria-hidden": !0,
          title: B,
          style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: "absolute", left: "50%" }
        },
        /* @__PURE__ */ t.createElement("option", { value: a.valueMap ? a.valueMap.call(void 0, m) : m })
      ),
      !P && /* @__PURE__ */ t.createElement(
        mt,
        {
          ...M,
          popupClass: ee(M.popupClass, "k-multiselecttree-popup"),
          className: ee(M.className, { "k-rtl": T === "rtl" }),
          style: $e,
          anchor: M.anchor || C.current,
          show: s,
          onOpen: je,
          onClose: Ue,
          ref: j
        },
        a.filterable && /* @__PURE__ */ t.createElement(
          Ne,
          {
            value: a.filter === void 0 ? be : a.filter,
            ref: I,
            onChange: ke,
            onKeyDown: Ce,
            tabIndex: H,
            size: v,
            rounded: K,
            fillMode: W,
            renderListFilterWrapper: !0,
            renderPrefixSeparator: !0
          }
        ),
        q.length > 0 ? /* @__PURE__ */ t.createElement(
          Te,
          {
            style: { height: M.height },
            ref: k,
            tabIndex: H,
            data: q,
            focusIdField: S,
            textField: a.textField,
            checkField: fe,
            checkIndeterminateField: me,
            expandField: a.expandField,
            childrenField: ge,
            expandIcons: !0,
            onItemClick: U,
            onCheckChange: U,
            onExpandChange: Ee,
            checkboxes: !0,
            size: v,
            item: a.item,
            dir: T
          }
        ) : /* @__PURE__ */ t.createElement(xe, null, Q.toLanguageString(te, ne[te]))
      )
    ), P && tt());
    return B ? /* @__PURE__ */ t.createElement(
      Et,
      {
        label: B,
        editorValue: le,
        editorPlaceholder: de,
        editorValid: Se,
        editorDisabled: E,
        editorId: x,
        style: { width: L ? L.width : void 0 },
        children: we,
        dir: T
      }
    ) : we;
  }
), Mt = {
  opened: n.bool,
  disabled: n.bool,
  dir: n.string,
  tabIndex: n.number,
  accessKey: n.string,
  data: n.array,
  value: n.any,
  valueMap: n.func,
  placeholder: n.string,
  dataItemKey: n.string.isRequired,
  textField: n.string.isRequired,
  checkField: n.string,
  checkIndeterminateField: n.string,
  expandField: n.string,
  subItemsField: n.string,
  className: n.string,
  style: n.object,
  label: n.string,
  validationMessage: n.string,
  validityStyles: n.bool,
  valid: n.bool,
  required: n.bool,
  name: n.string,
  id: n.string,
  ariaLabelledBy: n.string,
  ariaDescribedBy: n.string,
  filterable: n.bool,
  filter: n.string,
  loading: n.bool,
  tags: n.arrayOf(
    n.shape({
      text: n.string,
      data: n.arrayOf(n.any)
    })
  ),
  popupSettings: n.shape({
    animate: n.oneOfType([
      n.bool,
      n.shape({
        openDuration: n.number,
        closeDuration: n.number
      })
    ]),
    popupClass: n.string,
    className: n.string,
    appendTo: n.any,
    width: n.oneOfType([n.string, n.number]),
    height: n.oneOfType([n.string, n.number])
  }),
  onOpen: n.func,
  onClose: n.func,
  onFocus: n.func,
  onBlur: n.func,
  onChange: n.func,
  onFilterChange: n.func,
  onExpandChange: n.func,
  onCancel: n.func,
  item: n.func,
  listNoData: n.func,
  adaptiveTitle: n.string,
  adaptive: n.bool
};
Oe.displayName = "KendoReactMultiSelectTree";
Oe.propTypes = Mt;
export {
  Oe as MultiSelectTree,
  Rt as MultiSelectTreePropsContext
};
