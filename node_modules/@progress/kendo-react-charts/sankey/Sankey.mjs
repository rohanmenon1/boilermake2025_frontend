/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import { sankeyTheme as w, Sankey as H } from "@progress/kendo-charts";
import { validatePackage as D, useRtl as I, canUseDOM as K } from "@progress/kendo-react-common";
import { packageMetadata as M } from "../package-metadata.mjs";
import { sankeyPropTypes as V } from "./propTypes.mjs";
import { TooltipComponent as A, NodeTooltipContent as F, LinkTooltipContent as U } from "./SankeyTooltip.mjs";
const S = 12, k = {
  offset: S,
  visible: !0
}, W = ["nodeEnter", "nodeLeave", "linkEnter", "linkLeave", "nodeClick", "linkClick"], $ = (n, c) => {
  n && (n.unbind(), W.forEach((o) => {
    c[o] && n.bind(o, c[o]);
  }));
}, P = t.forwardRef((n, c) => {
  D(M);
  const o = t.useRef(null), r = t.useRef(null), s = I(o, n.dir, [n.dir, o.current]), d = t.useRef(null), {
    data: p,
    links: m,
    nodes: y,
    labels: v,
    title: E,
    legend: C,
    tooltip: u = k,
    disableAutoLayout: b,
    disableKeyboardNavigation: g
  } = n, T = t.useRef();
  T.current = n;
  const [L, R] = t.useState(null), h = t.useCallback(
    (l) => {
      const {
        visible: a,
        offset: e = S,
        nodeComponent: f = F,
        linkComponent: x = U
      } = { ...k, ...u };
      if (a) {
        const O = {
          event: l,
          offset: e,
          dir: s,
          Content: l.targetType === "node" ? f : x
        };
        R(O);
      }
    },
    [u, s]
  ), N = t.useCallback(() => {
    R(null);
  }, []), i = t.useCallback((l, a) => {
    const e = T.current[l];
    if (e) {
      const f = {
        ...a,
        nativeEvent: a.originalEvent,
        target: d.current
      };
      e.call(void 0, f);
    }
  }, []);
  return t.useEffect(() => {
    const l = {
      data: p,
      links: m,
      nodes: y,
      labels: v,
      title: E,
      legend: C,
      disableAutoLayout: b,
      disableKeyboardNavigation: g,
      rtl: s === "rtl",
      tooltip: { ...k, ...u }
    };
    if (r.current)
      r.current.setOptions(l);
    else if (K && o.current) {
      const a = w(o.current);
      r.current = new H(o.current, l, a), $(r.current, {
        nodeEnter: (e) => {
          i("onNodeEnter", e);
        },
        nodeLeave: (e) => {
          i("onNodeLeave", e);
        },
        linkEnter: (e) => {
          i("onLinkEnter", e);
        },
        linkLeave: (e) => {
          i("onLinkLeave", e);
        },
        nodeClick: (e) => {
          i("onNodeClick", e);
        },
        linkClick: (e) => {
          i("onLinkClick", e);
        }
      }), r.current.bind("tooltipShow", h), r.current.bind("tooltipHide", N);
    }
    return () => {
      r.current && (r.current.destroy(), r.current = null);
    };
  }, [
    p,
    m,
    y,
    v,
    E,
    C,
    b,
    g,
    s,
    u,
    N,
    h,
    i
  ]), t.useImperativeHandle(
    d,
    () => ({
      get element() {
        return o.current;
      },
      exportVisual: (l) => r.current.exportVisual(l),
      props: n
    }),
    []
  ), t.useImperativeHandle(c, () => d.current), /* @__PURE__ */ t.createElement(t.Fragment, null, /* @__PURE__ */ t.createElement("div", { ref: o, className: n.className, style: n.style, dir: s }), L && /* @__PURE__ */ t.createElement(A, { ...L }));
});
P.propTypes = V;
P.displayName = "KendoReactSankey";
export {
  P as Sankey
};
