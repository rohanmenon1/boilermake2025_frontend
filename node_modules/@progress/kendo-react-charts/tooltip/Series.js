/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const f=require("react"),m=require("@progress/kendo-react-common"),S=require("@progress/kendo-charts"),h=require("./Point.js"),y=require("./SharedTooltipContent.js"),T=require("./Popup.js"),C=require("../ChartContext.js");function O(p){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(p){for(const e in p)if(e!=="default"){const n=Object.getOwnPropertyDescriptor(p,e);Object.defineProperty(t,e,n.get?n:{enumerable:!0,get:()=>p[e]})}}return t.default=p,Object.freeze(t)}const a=O(f),x="k-chart-shared-tooltip",g="k-chart-tooltip-inverse",l=class l extends a.Component{constructor(){super(...arguments),this.context=null,this.state={popupShown:!1},this.chartObserver=null}componentDidMount(){this.chartObserver=new S.InstanceObserver(this,{showTooltip:"onShowTooltip",hideTooltip:"onHideTooltip"}),this.context.observersStore.dispatch({type:"add",payload:this.chartObserver})}render(){const{popupContext:t,shared:e,className:n,...r}=this.state,i=this.state.popupShown?()=>{const o=this.findRenderFunction();if(e)return o!==null?o(t):a.createElement(y.SharedTooltipContent,{...t});const d=t.point,u=this.findRenderFunctionByIndex(d.series.index);return u!==null?u(t):o!==null?o(t):a.createElement("span",{dangerouslySetInnerHTML:{__html:t.point.formattedValue}})}:Function.prototype,s=m.classNames({[x]:e,[g]:!!n});return a.createElement(T.TooltipPopup,{...r,popupContent:i,className:s})}componentWillUnmount(){this.context.observersStore.dispatch({type:"remove",payload:this.chartObserver})}onShowTooltip(t){const{anchor:e,style:n,shared:r,className:i,crosshair:s}=t;let o;s||(r?o=this.createSharedTooltipContext(t):o=this.createTooltipContext(t),this.setState({popupShown:!0,popupAlign:e.align,popupOffset:e.point,popupContext:o,popupStyles:n,className:i,shared:r}))}onHideTooltip(){this.setState({popupShown:!1,popupStyles:{},className:void 0})}createSharedTooltipContext(t){const{points:e,categoryText:n}=t,r=e.filter(o=>typeof o.series.name!="undefined").length>0,i=t.series.length>1;let s=1;return r&&s++,i&&s++,{categoryText:n,colorMarker:i,colspan:s,nameColumn:r,points:t.points.map(o=>new h.TooltipPoint(o,t.format))}}createTooltipContext(t){const{point:e,format:n}=t;return{point:new h.TooltipPoint(e,n)}}findRenderFunctionByIndex(t){const e=this.context.optionsStore.getState().series;return e!==void 0&&Array.isArray(e)&&e[t]!==void 0&&e[t].hasOwnProperty("tooltip")&&e[t].tooltip.hasOwnProperty("render")?e[t].tooltip.render:null}findRenderFunction(){const t=this.context.optionsStore.getState().tooltip;return t!==void 0&&t.hasOwnProperty("render")?t.render:null}};l.contextType=C.ChartContext;let c=l;exports.SeriesTooltip=c;
