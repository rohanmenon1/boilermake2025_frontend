/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import a from "prop-types";
import { validatePackage as I, useUnstyled as j, useCustomComponent as x, useAsyncFocusBlur as w, classNames as h, uTextBox as C } from "@progress/kendo-react-common";
import { packageMetadata as H } from "../package-metadata.mjs";
const B = t.forwardRef((e, F) => {
  I(H);
  const l = t.useRef(null), o = t.useRef(null), r = t.useRef(), i = j(), s = i && i.uTextBox, b = t.useCallback(() => {
    var n;
    return r.current !== void 0 ? r.current : (n = l.current) == null ? void 0 : n.value;
  }, []);
  t.useImperativeHandle(o, () => ({
    get element() {
      return l.current;
    },
    get name() {
      return l.current && l.current.name;
    },
    get value() {
      return b();
    }
  })), t.useImperativeHandle(F, () => o.current);
  const {
    size: c = u.size,
    fillMode: d = u.fillMode,
    rounded: f = u.rounded,
    autoFocus: y = u.autoFocus,
    inputAttributes: E,
    className: m,
    dir: R,
    style: _,
    prefix: M = u.prefix,
    suffix: N = u.suffix,
    valid: D,
    // Destruct to avoid warning when used inside a form field
    modified: G,
    touched: K,
    visited: U,
    ...T
  } = e, [q] = x(M), [k] = x(N), [v, g] = t.useState(!1), z = (n) => {
    g(!0);
  }, O = (n) => {
    g(!1);
  }, P = t.useCallback(
    (n) => {
      r.current = n.target.value, e.onChange && e.onChange.call(void 0, {
        syntheticEvent: n,
        nativeEvent: n.nativeEvent,
        value: n.target.value,
        target: o.current
      }), r.current = void 0;
    },
    [e.onChange]
  ), { onFocus: S, onBlur: p } = w({
    onFocus: z,
    onBlur: O,
    onSyncFocus: e.onFocus,
    onSyncBlur: e.onBlur
  }), A = t.useMemo(
    () => h(
      C.wrapper({
        c: s,
        rounded: f,
        fillMode: d,
        size: c,
        focused: v,
        required: e.required,
        disabled: e.disabled,
        invalid: e.valid === !1
      }),
      m
    ),
    [m, d, v, e.disabled, e.required, e.valid, f, c, s]
  );
  return /* @__PURE__ */ t.createElement("span", { style: _, dir: R, className: A, onFocus: S, onBlur: p }, /* @__PURE__ */ t.createElement(q, null), /* @__PURE__ */ t.createElement(
    "input",
    {
      ref: l,
      className: h(C.inputInner({ c: s })),
      autoFocus: y,
      ...Object.assign({}, T, E),
      "aria-required": e.required,
      onChange: P
    }
  ), /* @__PURE__ */ t.createElement(k, null));
}), u = {
  prefix: (e) => null,
  suffix: (e) => null,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  autoFocus: !1
};
B.propTypes = {
  size: a.oneOf([null, "small", "medium", "large"]),
  rounded: a.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: a.oneOf([null, "solid", "flat", "outline"]),
  autoFocus: a.bool,
  inputAttributes: a.object
};
B.displayName = "KendoReactTextBoxComponent";
export {
  B as TextBox
};
