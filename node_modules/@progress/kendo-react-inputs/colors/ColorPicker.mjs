/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import a from "prop-types";
import { createPropsContext as Ve, validatePackage as He, usePropsContext as Ue, useAdaptiveModeContext as Ke, canUseDOM as We, Navigation as $e, getActiveElement as Ge, keepFocusInContainer as I, focusFirstFocusableChild as ue, useDir as Me, classNames as G, kendoThemeMaps as de, getTabIndex as Ze, IconWrap as je, svgIconPropType as qe } from "@progress/kendo-react-common";
import { packageMetadata as Je } from "../package-metadata.mjs";
import { Picker as Qe } from "./Picker.mjs";
import { ColorGradient as Xe } from "./ColorGradient.mjs";
import { ColorPalette as Ye, DEFAULT_PRESET as et, DEFAULT_TILE_SIZE as tt } from "./ColorPalette.mjs";
import { FlatColorPicker as z } from "./FlatColorPicker.mjs";
import { Button as nt } from "@progress/kendo-react-buttons";
import { caretAltDownIcon as at } from "@progress/kendo-svg-icons";
import { colorPickerAdaptiveTitle as pe, messages as B, flatColorPickerCancelBtn as fe, flatColorPickerApplyBtn as me, colorPickerDropdownButtonAriaLabel as ve } from "../messages/index.mjs";
import { useLocalization as rt } from "@progress/kendo-react-intl";
import { AdaptiveMode as ot } from "../common/AdaptiveMode.mjs";
import { ActionSheetContent as lt } from "@progress/kendo-react-layout";
const it = {
  opacity: !0
}, ct = {
  palette: et,
  tileSize: tt
}, M = (D) => D !== void 0, st = Ve(), ge = t.forwardRef((D, ke) => {
  var re, oe;
  He(Je);
  const o = Ue(st, D), b = rt(), Z = Ke(), {
    size: u = k.size,
    rounded: x = k.rounded,
    fillMode: S = k.fillMode,
    gradientSettings: C = k.gradientSettings,
    paletteSettings: j = k.paletteSettings,
    flatColorPickerSettings: w,
    view: d = o.views ? void 0 : k.view,
    views: c = d ? void 0 : k.views,
    activeView: q,
    popupSettings: m,
    valid: Ce,
    disabled: L,
    tabIndex: Ee,
    icon: N,
    svgIcon: O,
    iconClassName: T,
    onChange: F,
    onFocus: V,
    onBlur: H,
    onActiveColorClick: U,
    className: be,
    adaptive: we,
    adaptiveTitle: J = b.toLanguageString(pe, B[pe])
  } = o, s = t.useRef(null), y = t.useRef(null), P = t.useRef(null), f = t.useRef(null), E = t.useRef(), ye = t.useRef(null), [he, Q] = t.useState(!1), [Se, Te] = t.useState(o.defaultValue), [Pe, _e] = t.useState(!1), [_, Re] = t.useState(), K = M(o.value), v = M(o.open), l = K ? o.value : Se, g = v ? o.open : Pe, X = t.useRef(l), Y = t.useCallback(() => {
    s.current && s.current.focus();
  }, []);
  t.useImperativeHandle(
    ke,
    () => ({
      // we agreed that each element will have focus method exposed
      element: s.current,
      actionElement: ye.current,
      value: l,
      focus: Y
    }),
    [l, Y]
  );
  const Ae = !!(_ && Z && _ <= Z.medium && we);
  t.useEffect(() => {
    const e = We && window.ResizeObserver && new window.ResizeObserver(Oe.bind(void 0));
    return document != null && document.body && e && e.observe(document.body), () => {
      document != null && document.body && e && e.disconnect();
    };
  }, []);
  const r = t.useCallback(
    (e, i) => {
      v || (!e && !i && s && s.current && s.current.focus(), _e(e));
    },
    [v]
  ), ee = t.useMemo(() => new $e({
    root: s,
    selectors: [".k-colorpicker", ".k-color-picker-popup"],
    tabIndex: 0,
    keyboardEvents: {
      keydown: {
        Escape: (e, i, n) => {
          r(!1);
        },
        Enter: (e, i, n) => {
          !v && e === s.current && (n.preventDefault(), n.stopPropagation(), r(!0));
        },
        ArrowDown: (e, i, n) => {
          n.altKey && (n.preventDefault(), n.stopPropagation(), r(!0));
        },
        ArrowUp: (e, i, n) => {
          n.altKey && (n.preventDefault(), n.stopPropagation(), r(!1));
        },
        Tab: (e, i, n) => {
          var h, le, ie;
          if (Ge(document) !== s.current) {
            const ce = (h = P.current) == null ? void 0 : h.wrapperRef.current, A = (le = y.current) == null ? void 0 : le.wrapperRef.current, se = (ie = f.current) == null ? void 0 : ie.element;
            d === "palette" && ce ? I(n, ce) : d === "gradient" && A ? I(n, A) : d === "combo" && A ? I(n, A.parentElement) : c && se && I(n, se);
          }
        }
      }
    }
  }), [r, v]), Ie = t.useCallback(ee.triggerKeyboardEvent.bind(ee), []), ze = t.useCallback(() => {
    v || (y.current && y.current.wrapperRef.current ? ue(y.current.wrapperRef.current) : P.current ? P.current.focus() : f.current && f.current.element && ue(f.current.element));
  }, [v]), R = (e) => X.current = e, te = t.useCallback(
    (e) => {
      const i = {
        value: X.current,
        nativeEvent: e.nativeEvent,
        syntheticEvent: e
      };
      p(i), r(!g, !0);
    },
    [g]
  ), W = t.useCallback(() => {
    r(!1, !0);
  }, [r]), Be = t.useCallback(
    (e) => {
      U && U.call(void 0, {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        value: l,
        target: {
          element: s.current,
          value: l
        }
      });
    },
    [U, l]
  ), De = t.useCallback(
    (e) => {
      E.current ? (clearTimeout(E.current), E.current = void 0) : Q(!0), V && V.call(void 0, {
        nativeEvent: e.nativeEvent,
        syntheticEvent: e
      });
    },
    [V]
  ), xe = t.useCallback(() => {
    r(!1, !0), Q(!1), E.current = void 0;
  }, []), Le = t.useCallback(
    (e) => {
      clearTimeout(E.current), E.current = window.setTimeout(xe), H && H.call(void 0, {
        nativeEvent: e.nativeEvent,
        syntheticEvent: e
      });
    },
    [H]
  ), p = t.useCallback(
    (e, i) => {
      var h;
      const n = i ? e.rgbaValue || "" : (h = e.value) != null ? h : "";
      K || Te(n), F && F.call(void 0, {
        value: n,
        nativeEvent: e.nativeEvent,
        syntheticEvent: e.syntheticEvent,
        target: {
          element: s.current,
          value: n
        }
      }), r(!1);
    },
    [K, F]
  ), ne = t.useCallback(
    (e) => p(e, !0),
    [M, p]
  ), $ = t.useCallback(
    (e) => /* @__PURE__ */ t.createElement(t.Fragment, null, (d === "combo" || d === "gradient") && /* @__PURE__ */ t.createElement(
      Xe,
      {
        ...C,
        _adaptive: e,
        ref: y,
        isInsidePopup: !0,
        size: e ? "large" : u,
        fillMode: S,
        value: l,
        onChange: p
      }
    ), (d === "combo" || d === "palette") && /* @__PURE__ */ t.createElement(
      Ye,
      {
        ...j,
        ref: P,
        size: e ? "large" : u,
        value: l,
        onChange: ne
      }
    ), c && c[0] === "gradient" && c[1] === "palette" && /* @__PURE__ */ t.createElement(
      z,
      {
        ...w,
        _gradientSettings: { _adaptive: e, ...C },
        ref: f,
        size: e ? "large" : u,
        views: ["gradient", "palette"],
        activeView: q,
        setOpen: r,
        showButtons: !e,
        value: l,
        onChange: p,
        setAdaptiveModeValue: R
      }
    ), c && c[0] === "palette" && c[1] === "gradient" && /* @__PURE__ */ t.createElement(
      z,
      {
        ...w,
        _gradientSettings: { _adaptive: e, ...C },
        ref: f,
        size: e ? "large" : u,
        views: ["palette", "gradient"],
        setOpen: r,
        showButtons: !e,
        value: l,
        onChange: p,
        setAdaptiveModeValue: R
      }
    ), c && c.includes("gradient") && !c.includes("palette") && /* @__PURE__ */ t.createElement(
      z,
      {
        ...w,
        _gradientSettings: { _adaptive: e, ...C },
        ref: f,
        size: e ? "large" : u,
        views: ["gradient"],
        showButtons: !e,
        setOpen: r,
        value: l,
        onChange: p,
        setAdaptiveModeValue: R
      }
    ), c && c.includes("palette") && !c.includes("gradient") && /* @__PURE__ */ t.createElement(
      z,
      {
        ...w,
        _gradientSettings: { _adaptive: e, ...C },
        ref: f,
        size: e ? "large" : u,
        views: ["palette"],
        showButtons: !e,
        setOpen: r,
        value: l,
        onChange: p,
        setAdaptiveModeValue: R
      }
    )),
    [
      q,
      S,
      w,
      C,
      p,
      ne,
      j,
      r,
      u,
      l,
      d,
      c
    ]
  ), Ne = t.useCallback(() => {
    var i;
    const e = {
      animation: !!((i = m == null ? void 0 : m.animate) == null || i),
      title: J,
      expand: g,
      onClose: W,
      windowWidth: _,
      footer: {
        cancelText: b.toLanguageString(fe, B[fe]),
        onCancel: W,
        applyText: b.toLanguageString(me, B[me]),
        onApply: te
      }
    };
    return /* @__PURE__ */ t.createElement(ot, { ...e }, /* @__PURE__ */ t.createElement(lt, { overflowHidden: !0 }, $(!0)));
  }, [
    m == null ? void 0 : m.animate,
    J,
    g,
    W,
    _,
    b,
    te,
    $
  ]), Oe = t.useCallback((e) => {
    for (const i of e)
      Re(i.target.clientWidth);
  }, []), ae = Me(s, o.dir), Fe = Ce !== !1;
  return /* @__PURE__ */ t.createElement(
    "span",
    {
      id: o.id,
      role: "combobox",
      "aria-label": o.ariaLabel,
      "aria-labelledby": o.ariaLabelledBy,
      "aria-describedby": o.ariaDescribedBy,
      "aria-haspopup": "dialog",
      "aria-expanded": g,
      "aria-controls": `k-colorpicker-popup-${(re = o.id) != null ? re : 0}`,
      "aria-disabled": L ? "true" : void 0,
      className: G("k-colorpicker", "k-picker", "k-icon-picker", {
        [`k-picker-${de.sizeMap[u] || u}`]: u,
        [`k-picker-${S}`]: S,
        [`k-rounded-${de.roundedMap[x] || x}`]: x,
        "k-invalid": !Fe,
        "k-disabled": L,
        "k-focus": he,
        className: be
      }),
      ref: s,
      tabIndex: Ze(Ee, L),
      title: o.title,
      onKeyDown: Ie,
      onFocus: De,
      onBlur: Le,
      dir: ae
    },
    /* @__PURE__ */ t.createElement(
      Qe,
      {
        dir: ae,
        open: g,
        onOpen: ze,
        popupAnchor: s.current || void 0,
        popupSettings: { id: `k-colorpicker-popup-${(oe = o.id) != null ? oe : 0}`, ...m },
        input: /* @__PURE__ */ t.createElement("span", { onClick: Be, className: "k-input-inner" }, /* @__PURE__ */ t.createElement(
          "span",
          {
            className: G("k-value-icon", "k-color-preview", {
              "k-no-color": !l,
              "k-icon-color-preview": N || O || T
            })
          },
          T && /* @__PURE__ */ t.createElement("span", { className: G("k-color-preview-icon", T) }),
          !T && (N || O) && /* @__PURE__ */ t.createElement(je, { name: N, icon: O }),
          /* @__PURE__ */ t.createElement("span", { className: "k-color-preview-mask", style: { backgroundColor: l } })
        )),
        button: /* @__PURE__ */ t.createElement(
          nt,
          {
            tabIndex: -1,
            type: "button",
            onClick: () => r(!g),
            className: "k-input-button",
            rounded: null,
            icon: "caret-alt-down",
            svgIcon: at,
            "aria-label": b.toLanguageString(
              ve,
              B[ve]
            )
          }
        ),
        content: $(!1),
        _mobileMode: Ae,
        _actionSheet: Ne()
      }
    )
  );
});
ge.propTypes = {
  value: a.string,
  defaultValue: a.string,
  disabled: a.bool,
  view: a.oneOf(["gradient", "palette", "combo"]),
  views: a.arrayOf(a.oneOf(["gradient", "palette"])),
  dir: a.string,
  id: a.string,
  icon: a.string,
  svgIcon: qe,
  ariaLabelledBy: a.string,
  ariaDescribedBy: a.string,
  size: a.oneOf([null, "small", "medium", "large"]),
  rounded: a.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: a.oneOf([null, "solid", "flat", "outline"]),
  className: a.string,
  adaptive: a.bool,
  adaptiveTitle: a.string
};
const k = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  view: "palette",
  views: ["gradient", "palette"],
  gradientSettings: it,
  paletteSettings: ct
};
ge.displayName = "KendoColorPicker";
export {
  ge as ColorPicker,
  st as ColorPickerPropsContext
};
