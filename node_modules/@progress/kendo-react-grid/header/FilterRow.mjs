/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as i from "react";
import { GridFilterCell as R } from "../cells/GridFilterCell.mjs";
import { getFilterType as h, operatorMap as b, booleanFilterValues as w } from "../filterCommon.mjs";
import { tableKeyboardNavigationTools as z, HeaderTdElement as N } from "@progress/kendo-react-data-tools";
import { filterAriaLabel as u, messages as P } from "../messages/index.mjs";
import { classNames as A } from "@progress/kendo-react-common";
import { clientColumn as G, isClientReference as F, resolveCells as S } from "../utils/index.mjs";
import { GridFilterCellContainer as E } from "./client/GridFilterCellContainer.mjs";
import { GridFilterCellElementContainer as $ } from "./client/GridFilterCellElementContainer.mjs";
const O = "k-table-row k-filter-row", B = (t) => {
  const x = (e, r) => {
    let l = `${r ? "k-grid-header-sticky" : ""}`;
    return t.sort && t.sort.filter((o) => o.field === e).length > 0 && (l += " k-sorted"), l;
  }, T = t.filter && t.filter.filters || [], k = (e) => {
    if (e === void 0)
      return;
    const r = T.filter(
      (l) => l.field === e
    );
    return r.length ? r[0] : void 0;
  };
  let y = 0, m = -1;
  const I = t.columns.filter((e) => e.children.length === 0).map((e) => {
    const r = h(e.filter), l = k(e.field), o = `${e.field} ${t.localization.toLanguageString(
      u,
      P[u]
    )}`;
    let n = l && l.value;
    n === void 0 && (n = r === "text" ? "" : null);
    const s = e.filterable && {
      field: e.field,
      title: e.filterTitle,
      value: n,
      operator: l && l.operator,
      operators: b(t.filterOperators[r] || [], t.localization),
      booleanValues: b(w, t.localization),
      filterType: r,
      ariaLabel: e.columnType === "reorder" ? "" : o,
      size: t.size
    }, d = e.declarationIndex >= 0 ? ++m : --y, C = {
      columnId: z.getFilterColumnId(e.id),
      navigatable: e.navigatable || t.navigatable,
      className: A("k-table-td", x(e.field, e.locked) || void 0),
      role: "gridcell",
      ariaLabel: e.columnType === "reorder" ? void 0 : o,
      ariaColumnIndex: e.ariaColumnIndex
    }, g = G(e), v = {
      column: g,
      filter: t.filter,
      field: e.field,
      render: t.cellRender
    };
    let f = null;
    if (s && e.columnType !== "reorder") {
      const a = e.filterCell ? e.filterCell : R;
      f = /* @__PURE__ */ i.createElement(E, { ...v, isClient: F(a) }, /* @__PURE__ */ i.createElement(a, { ...s }));
    }
    const c = S(t.cells, e.cells);
    if (c && c.filterCell) {
      const a = c.filterCell, L = F(a);
      return /* @__PURE__ */ i.createElement(
        E,
        {
          key: d,
          ...v,
          isClient: L,
          isCustom: !0
        },
        /* @__PURE__ */ i.createElement(a, { key: d, ...s, tdProps: C, index: m }, f)
      );
    }
    return /* @__PURE__ */ i.createElement($, { key: d, column: g }, /* @__PURE__ */ i.createElement(N, { ...C }, f));
  });
  return /* @__PURE__ */ i.createElement("tr", { className: O, "aria-rowindex": t.ariaRowIndex, role: "row" }, I);
};
export {
  O as FILTER_ROW_CLASS,
  B as FilterRow
};
