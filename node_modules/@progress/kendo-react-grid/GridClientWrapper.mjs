/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as i from "react";
import { canUseDOM as $, getActiveElement as zt, useDir as Nt, setScrollbarWidth as Fe, getter as J, getScrollbarWidth as Ot, RowHeightService as Le } from "@progress/kendo-react-common";
import { getSelectionOptions as Y, populateClipboardData as Bt, ClipboardActionType as me, getEditableOptions as Ut, tableKeyboardNavigation as T, ClipboardService as Vt, TableKeyboardNavigationContext as Wt, getSelectedStateFromKeyDown as _t, closestTagName as Ge, getColumnIndex as jt, getRowIndex as qt, editReducer as Xt, EDIT_ACTION as $t, getDetailExpandableOptions as Jt, detailExpandReducer as ze, getGroupExpandableOptions as Yt, groupExpandReducer as Qt, DETAIL_EXPAND_ACTION as Zt, getSelectedState as Ne, updateLeft as pt, updateRight as er } from "@progress/kendo-react-data-tools";
import { ColumnResize as tr } from "./drag/ColumnResize.mjs";
import { CommonDragLogic as rr } from "./drag/CommonDragLogic.mjs";
import { SAFARI_REGEX as nr } from "./constants/index.mjs";
import { getDefaultHeadContextMenuItems as or, getDefaultBodyContextMenuItems as ar, isRowReorderEnabled as ir, sanitizeColumns as dr, getDataAsArray as cr, firefox as Oe, firefoxMaxHeight as Be } from "./utils/index.mjs";
import { VirtualScrollFixed as Ue } from "./VirtualScrollFixed.mjs";
import { VirtualScroll as lr } from "./VirtualScroll.mjs";
import { GridContextMenu as sr } from "./contextMenu/GridContextMenu.mjs";
import { GridContextMenuAnchorPart as Ve } from "./contextMenu/enums.mjs";
import { normalize as ur, firstLevelSortSeqMap as gr } from "./sortCommon.mjs";
const fr = i.createContext(void 0), Sr = (t) => {
  var ke, Ke;
  const E = t.gridProps.isClient, [b, Pe] = i.useState({}), We = (e) => {
    e.event.preventDefault(), Pe({
      ...b,
      show: !0,
      offset: {
        left: e.event.pageX,
        top: e.event.pageY
      },
      dataItem: e.dataItem,
      field: e.field
    });
  }, he = () => {
    Pe({});
  }, P = i.useMemo(() => t.columnsRef.current.find((e) => e.field === b.field), [t.columnsRef, b]), be = i.useMemo(() => {
    const e = t.gridProps.sortable && (P == null ? void 0 : P.sortable);
    return or({
      sortable: !!e,
      selectable: Y(t.gridProps.selectable).enabled,
      clipboard: !!t.gridProps.clipboard
    });
  }, [P, t.gridProps.sortable, t.gridProps.selectable, t.gridProps.clipboard]), Ie = i.useMemo(() => {
    const e = t.gridProps.sortable && (P == null ? void 0 : P.sortable);
    return ar({
      sortable: !!e,
      selectable: Y(t.gridProps.selectable).enabled,
      clipboard: !!t.gridProps.clipboard,
      rowReorderable: ir(t.gridProps.rowReorderable)
    });
  }, [P, t.gridProps.sortable, t.gridProps.selectable, t.gridProps.clipboard]), _e = i.useMemo(() => {
    const e = (P == null ? void 0 : P.contextMenu) || t.gridProps.contextMenu, r = typeof e == "function" ? e(b) : e;
    if (r && b.offset) {
      const n = b.dataItem ? Ve.body : Ve.head, o = r[n], a = b.dataItem ? Ie : be;
      return o === !1 ? void 0 : o === !0 || o === void 0 ? a : o;
    }
  }, [t.gridProps.contextMenu, b, Ie, be, P]), je = (e) => {
    var l, f, m, s, C, Te, Me, Ae, He;
    const r = e.event.item, n = {
      target: R.current,
      syntheticEvent: e.event.syntheticEvent,
      nativeEvent: e.event.nativeEvent,
      menuItem: r,
      ...e
    };
    t.gridProps.onContextMenuItemClick && u(t.gridProps.onContextMenuItemClick, n);
    const o = V(), a = {
      selectedField: t.gridProps.selectedField || "",
      componentId: t.id,
      dataItems: o,
      dataItem: e.dataItem,
      startRowIndex: -1,
      endRowIndex: -1,
      startColIndex: -1,
      endColIndex: -1,
      ctrlKey: !1,
      altKey: !1,
      metaKey: !1,
      shiftKey: !1,
      isDrag: !1,
      ...Y(t.gridProps.selectable),
      ...n
    }, d = o.findIndex((fe) => fe === e.dataItem);
    switch ((l = r.data) == null ? void 0 : l.action) {
      case "SortCommand":
        if (P) {
          const fe = (f = r.name) == null ? void 0 : f.toLowerCase().includes("asc"), Ft = ((m = r.name) == null ? void 0 : m.toLowerCase().includes("desc")) ? "desc" : void 0, Lt = fe ? "asc" : Ft, Gt = r.name ? Lt : void 0;
          Re(e.event.syntheticEvent, P, Gt);
        }
        break;
      case "SelectRowCommand":
        dt(a);
        break;
      case "SelectAllRowsCommand":
        it(a);
        break;
      case "ClearSelectionCommand":
        ct(a);
        break;
      case "ReorderRowCommand":
        G.current = e.dataItem, (s = r.name) != null && s.toLowerCase().includes("rowup") && d > 0 && A(e.event.syntheticEvent, d - 1, "before"), (C = r.name) != null && C.toLowerCase().includes("rowdown") && d < o.length - 1 && A(e.event.syntheticEvent, d + 1, "after"), (Te = r.name) != null && Te.toLowerCase().includes("rowtop") && A(e.event.syntheticEvent, 0, "before"), (Me = r.name) != null && Me.toLowerCase().includes("rowbottom") && A(e.event.syntheticEvent, o.length - 1, "after");
        break;
      case "CopySelectionCommand":
        B(
          me.copy,
          e.event.nativeEvent,
          {
            copyHeaders: !((Ae = r.name) != null && Ae.toLowerCase().includes("noheaders"))
          },
          e.dataItem,
          e.field
        );
        break;
      case "PasteCommand":
        B(
          me.paste,
          e.event.nativeEvent,
          {
            copyHeaders: !((He = r.name) != null && He.toLowerCase().includes("noheaders"))
          },
          e.dataItem,
          e.field
        );
        break;
    }
    he();
  }, z = () => {
    const e = g.current.filter((r) => r.declarationIndex >= 0 && r.parentIndex === -1);
    return dr(e);
  }, qe = (e, r, n) => {
    if (t.gridProps.onContextMenu && E) {
      const o = {
        target: R.current,
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        dataItem: r,
        field: n
      };
      u(t.gridProps.onContextMenu, o);
    }
    t.gridProps.contextMenu && We({
      event: e,
      dataItem: r,
      field: n
    });
  }, Xe = (e) => {
    if (e.target !== e.currentTarget)
      return;
    clearTimeout(se.current), c.current && (c.current.table = x.current);
    const r = e.currentTarget.scrollLeft, n = e.currentTarget.scrollTop, o = t.gridProps.scrollable === "virtual";
    t.gridProps.columnVirtualization && (!o || n === le.current) && (se.current = window.setTimeout(() => {
      re();
    }, 0)), t.gridProps.scrollLeftRef && (t.gridProps.scrollLeftRef.current = r), L.current && L.current.setScrollLeft(r), F.current && F.current.setScrollLeft(r), c.current && n !== le.current && c.current.scrollHandler(e), t.gridProps.onScroll && E && u(t.gridProps.onScroll, {
      ...h(e)
    }), le.current = n;
  }, $e = (e) => {
    var n, o;
    T.onKeyDown(e, {
      navigatable: t.gridProps.navigatable || !1,
      contextStateRef: y,
      navigationStateRef: D,
      onNavigationAction: Ye,
      columns: z()
    }), T.onGetSnapshotBeforeUpdate({
      document: v(),
      contextStateRef: y,
      navigationStateRef: D
    });
    const r = {
      dataItems: U(),
      mode: I.mode,
      cell: I.cell,
      componentId: t.id,
      selectedField: t.gridProps.selectedField,
      ...h(e)
    };
    if (t.gridProps.onKeyDown && E && u(t.gridProps.onKeyDown, r), !t.gridProps.selectedField && I.enabled && t.gridProps.dataItemKey) {
      const a = _t({
        event: r,
        selectedState: (n = t.gridProps.select) != null ? n : {},
        dataItemKey: t.gridProps.dataItemKey
      });
      if (a === t.gridProps.select)
        return;
      const d = e.target, l = Ge(d, "TD"), f = Ge(d, "TR"), m = jt(l), s = qt(f);
      if (m !== void 0 && s !== void 0) {
        const C = (o = cr(t.gridProps.data)) == null ? void 0 : o[s];
        t.gridProps.onSelectionChange && u(t.gridProps.onSelectionChange, {
          ...r,
          select: a,
          dataItem: C,
          startRowIndex: s,
          startColIndex: m,
          startDataItem: C,
          endDataItem: C,
          endRowIndex: s,
          endColIndex: m,
          ctrlKey: e.ctrlKey,
          altKey: e.altKey,
          metaKey: e.metaKey,
          shiftKey: e.shiftKey,
          isDrag: !1
        });
      }
    }
  }, Je = (e) => {
    T.onFocus(e, {
      navigatable: !!t.gridProps.navigatable,
      contextStateRef: y
    });
  }, Ye = (e) => {
    if (e.action === "moveToNextPage" && st(e.event), e.action === "moveToPrevPage" && ut(e.event), e.focusElement && e.action === "reorderToRight") {
      const r = parseInt(e.focusElement.ariaColIndex, 10) - 1;
      r < g.current.length - 1 && Z(r, r + 1, e.event);
    }
    if (e.focusElement && e.action === "reorderToLeft") {
      const r = parseInt(e.focusElement.ariaColIndex, 10) - 1;
      r > 0 && Z(r, r - 1, e.event);
    }
    if (t.gridProps.onNavigationAction && E) {
      const r = {
        focusElement: e.focusElement,
        ...h(e.event)
      };
      u(t.gridProps.onNavigationAction, r);
    }
  }, Qe = (e, r) => {
    t.gridProps.onRowClick && e.target.nodeName === "TD" && u(t.gridProps.onRowClick, {
      dataItem: r,
      ...h(e)
    });
  }, Ze = (e, r) => {
    t.gridProps.onRowDoubleClick && e.target.nodeName === "TD" && u(t.gridProps.onRowDoubleClick, {
      dataItem: r,
      ...h(e)
    });
  }, pe = (e, r, n) => {
    if (Se.enabled && Se.mode === "incell" && t.gridProps.dataItemKey) {
      const o = Xt(t.gridProps.edit, {
        type: $t.ENTER_FIELD_EDIT,
        payload: { id: r[t.gridProps.dataItemKey], field: n }
      });
      t.gridProps.onEditChange && u(t.gridProps.onEditChange, {
        edit: o,
        ...h(e)
      });
    }
  }, et = (e, r) => {
    var o;
    if (Jt(t.detailExpandable).enabled) {
      const a = ze((o = t.gridProps.detailExpand) != null ? o : {}, e);
      t.gridProps.onDetailExpandChange && u(t.gridProps.onDetailExpandChange, {
        ...h(r),
        detailExpand: a
      });
    }
  }, tt = (e, r) => {
    var o;
    const n = Yt(
      typeof t.gridProps.groupable == "object" ? t.gridProps.groupable.expandable !== !1 : t.gridProps.groupable
    );
    if (n.enabled) {
      const a = Qt((o = t.gridProps.groupExpand) != null ? o : [], e, n);
      t.gridProps.onGroupExpandChange && u(t.gridProps.onGroupExpandChange, {
        ...h(r),
        groupExpand: a
      });
    }
  }, Re = (e, r, n) => {
    const { allowUnsort: o, mode: a } = ur(t.gridProps.sortable || !1, r.sortable || !1), d = (t.gridProps.sort || []).filter((m) => m.field === r.field)[0], l = n || gr[o][d && d.dir || ""], f = a === "single" ? [] : (t.gridProps.sort || []).filter((m) => m.field !== r.field);
    l !== "" && r.field && f.push({ field: r.field, dir: l }), Ce(f, e);
  }, rt = (e) => {
    var r;
    if (e.field === t.gridProps.expandField || e._expand || t.gridProps.group && e.field === void 0) {
      if (t.gridProps.onExpandChange) {
        const n = t.gridProps.dataItemKey ? ze((r = t.gridProps.detailExpand) != null ? r : {}, {
          type: Zt.SET,
          id: e.dataItem[t.gridProps.dataItemKey],
          payload: e.value
        }) : t.gridProps.detailExpand;
        u(t.gridProps.onExpandChange, {
          ...h(e.syntheticEvent),
          expand: n,
          dataItem: e.dataItem,
          dataIndex: e.dataIndex,
          value: e.value
        });
      }
      return;
    }
    t.gridProps.onItemChange && u(t.gridProps.onItemChange, {
      ...h(e.syntheticEvent),
      dataItem: e.dataItem,
      dataIndex: e.dataIndex,
      field: e.field,
      value: e.value
    });
  }, nt = (e) => {
    var r;
    if (t.gridProps.onSelectionChange && I.enabled) {
      const { event: n, dataItem: o, dataIndex: a, columnIndex: d } = e, l = {
        ...h(n.syntheticEvent),
        dataItem: o,
        startColIndex: d,
        endColIndex: d,
        startRowIndex: a,
        endRowIndex: a,
        dataItems: U(),
        altKey: !1,
        ctrlKey: !1,
        shiftKey: !1,
        metaKey: !1,
        mode: I.mode,
        cell: I.cell,
        isDrag: !1,
        componentId: t.id,
        selectedField: t.gridProps.selectedField || ""
      };
      u(t.gridProps.onSelectionChange, {
        ...l,
        select: t.gridProps.dataItemKey ? Ne({
          event: l,
          selectedState: (r = t.gridProps.select) != null ? r : {},
          dataItemKey: t.gridProps.dataItemKey
        }) : {}
      });
    }
  }, ot = (e) => {
    var r;
    if (t.gridProps.onHeaderSelectionChange && I.enabled) {
      const n = U();
      u(t.gridProps.onHeaderSelectionChange, {
        select: e.syntheticEvent.target.checked ? n.reduce((o, a) => (t.gridProps.dataItemKey && J(t.gridProps.dataItemKey)(a) !== void 0 && (o[J(t.gridProps.dataItemKey)(a)] = !0), o), {}) : {},
        field: e.field,
        nativeEvent: e.syntheticEvent && e.syntheticEvent.nativeEvent,
        syntheticEvent: e.syntheticEvent,
        target: R.current,
        dataItems: n,
        selectedField: (r = t.gridProps.selectedField) != null ? r : ""
      });
    }
  }, N = (e, r) => {
    t.gridProps.onSelectionChange && I.enabled && u(t.gridProps.onSelectionChange, {
      ...e,
      select: r
    });
  }, at = (e) => {
    var r;
    if (t.gridProps.onSelectionChange && I.enabled) {
      const n = V()[e.startRowIndex], o = V()[e.endRowIndex], a = {
        syntheticEvent: void 0,
        target: R.current,
        selectedField: t.gridProps.selectedField || "",
        componentId: t.id,
        dataItems: U(),
        dataItem: null,
        startDataItem: n,
        endDataItem: o,
        ...e
      }, d = Ne({
        event: a,
        selectedState: (r = t.gridProps.select) != null ? r : {},
        // Thats kinda strange, even through the `dataItemKey` is required by the `getSelectedState`
        // it does work correctly even without it
        dataItemKey: t.gridProps.dataItemKey
      });
      N(a, d);
    }
  }, it = (e) => {
    if (t.gridProps.onSelectionChange && I.enabled) {
      const r = e.dataItems[0], n = e.dataItems[e.dataItems.length - 1], o = {}, a = {
        ...e,
        startDataItem: r,
        endDataItem: n,
        startRowIndex: 0,
        endRowIndex: e.dataItems.length - 1,
        startColIndex: 0,
        endColIndex: g.current.length - 1
      };
      e.dataItems.forEach((d) => {
        const f = J(t.gridProps.dataItemKey)(d);
        o[f] = e.cell ? [...Array(g.current.length).keys()] : !0;
      }), N(a, o);
    }
  }, dt = (e) => {
    if (t.gridProps.onSelectionChange && I.enabled) {
      const n = J(t.gridProps.dataItemKey)(e.dataItem), o = 0, a = g.current.length - 1, d = e.dataItems.findIndex(
        (C) => C[t.gridProps.dataItemKey] === e.dataItem[t.gridProps.dataItemKey]
      ), m = {
        ...e,
        startDataItem: d,
        endDataItem: d,
        startRowIndex: d,
        endRowIndex: d,
        startColIndex: o,
        endColIndex: a
      }, s = e.mode === "multiple" ? t.gridProps.select || {} : {};
      s[n] === !0 || Array.isArray(s[n]) && s[n].length === g.current.length ? delete s[n] : s[n] = e.cell ? [...Array(g.current.length).keys()] : !0, N(m, s);
    }
  }, ct = (e) => {
    t.gridProps.onSelectionChange && I.enabled && N(e, {});
  }, M = (e, r, n, o, a) => {
    const d = t.gridProps.onDataStateChange;
    if (e) {
      const l = { ...h(o), ...r, targetEvent: a };
      u(e, l);
    } else
      d && u(d, {
        ...h(o),
        targetEvent: a || {},
        dataState: {
          ...Ct(),
          ...n
        }
      });
  }, O = (e, r, n) => {
    M(
      t.gridProps.onPageChange,
      { page: e },
      { skip: e.skip, take: e.take },
      r,
      n
    );
  }, lt = () => {
    let e = t.gridProps.total || 0;
    return Array.isArray(t.gridProps.data) ? e = e || t.gridProps.data.length : t.gridProps.data && (e = e || t.gridProps.data.total), e;
  }, st = (e) => {
    var a, d;
    const r = (d = (a = t.gridProps.take) != null ? a : t.gridProps.pageSize) != null ? d : 0, n = (t.gridProps.skip || 0) + r, o = lt();
    n < o && O({ skip: n, take: r }, e);
  }, ut = (e) => {
    var o, a;
    const r = (a = (o = t.gridProps.take) != null ? o : t.gridProps.pageSize) != null ? a : 0, n = (t.gridProps.skip || 0) - r;
    n >= 0 && O({ skip: n, take: r }, e);
  }, gt = (e) => {
    O({ skip: e.skip, take: e.take }, e.syntheticEvent, e.targetEvent);
  }, Ce = (e, r) => {
    M(
      t.gridProps.onSortChange,
      { sort: e },
      { sort: e, ...t.gridProps.scrollable === "virtual" ? { skip: 0 } : {} },
      r
    );
  }, ft = (e, r) => {
    M(
      t.gridProps.onFilterChange,
      { filter: e },
      { filter: e || void 0, skip: 0 },
      r
    );
  }, mt = (e) => {
    const r = t.gridProps.searchFields || g.current.map((a) => a.field) || [], n = e.nativeEvent.target.value, o = {
      logic: "or",
      filters: r.filter((a) => a !== void 0).map((a) => {
        var d;
        return typeof a == "string" ? { field: a, value: n, operator: "contains" } : {
          value: n,
          operator: (d = a.operator) != null ? d : "contains",
          field: a.field,
          ignoreCase: a.ignoreCase
        };
      })
    };
    M(
      t.gridProps.onSearchChange,
      {
        search: o
      },
      {},
      e.syntheticEvent
    );
  }, Q = (e, r) => {
    const n = r.nativeEvent ? r : { nativeEvent: r.nativeEvent || r.originalEvent };
    e.length === 0 && t.gridProps.navigatable && (ie.current = !0), M(
      t.gridProps.onGroupChange,
      { group: e },
      { group: e, skip: 0 },
      n
    );
  }, Pt = (e) => {
    if (t.gridProps.onColumnsStateChange) {
      const r = {
        target: R.current,
        columnsState: e
      };
      u(t.gridProps.onColumnsStateChange, r);
    }
  }, Z = (e, r, n) => {
    const o = g.current[e], a = o.depth, d = (s) => {
      do
        s++;
      while (s < g.current.length && g.current[s].depth > a);
      return s;
    }, l = g.current.splice(e, d(e) - e);
    g.current.splice(e < r ? d(r - l.length) : r, 0, ...l), g.current.filter((s) => s.declarationIndex >= 0).forEach((s, C) => s.orderIndex = C);
    const f = g.current[e].locked && g.current[r].locked;
    pt(t.columnsMapRef, g.current, f || X.current), er(t.columnsMapRef, g.current, f || X.current), ae.current && (X.current = !1, ae.current = !1);
    const m = z();
    if (re(), t.gridProps.onColumnReorder) {
      const s = {
        target: R.current,
        columns: m,
        columnId: o.id,
        nativeEvent: n
      };
      u(t.gridProps.onColumnReorder, s);
    }
  }, A = (e, r, n) => {
    const o = typeof t.gridProps.rowReorderable == "object" ? t.gridProps.rowReorderable.enabled : t.gridProps.rowReorderable;
    if (n === "forbidden" || !o || !G.current)
      return;
    const { slicedData: a, dataRef: d } = t, l = (a || d)[r];
    t.gridProps.onRowReorder && u(t.gridProps.onRowReorder, {
      draggedDataItems: [G.current],
      droppedDataItem: l == null ? void 0 : l.dataItem,
      dropPosition: n,
      nativeEvent: e.originalEvent,
      dragEvent: e,
      target: R.current
    }), G.current = null;
  }, ht = (e, r, n) => {
    if (t.gridProps.group === void 0)
      return;
    const o = t.gridProps.group.slice();
    o.splice(r, 0, ...o.splice(e, 1)), Q(o, n);
  }, ve = (e, r, n) => {
    const o = g.current[e].field;
    if (!o)
      return;
    const a = (t.gridProps.group || []).slice();
    a.splice(r, 0, { field: o }), Q(a, n);
  }, bt = (e, r) => {
    const n = S.current.getCurrentGroupsLength;
    ve(e, n, r);
  }, p = () => {
    let e = 0;
    if (!w.current.colGroupMain)
      return;
    const r = w.current.colGroupMain.children;
    for (let n = 0; n < r.length; n++) {
      const o = r[n].width;
      if (!o)
        return;
      e += parseFloat(o.toString());
    }
    e = Math.round(e), L.current && L.current.setWidth(e), F.current && F.current.setWidth(e), x.current && (x.current.style.width = e + "px");
  }, B = i.useCallback(
    (e, r, n, o, a) => {
      var m;
      if (!It() && !n || !e)
        return;
      const d = {
        type: e,
        nativeEvent: r,
        columns: g.current,
        dataItemKey: t.gridProps.dataItemKey || "",
        dataItem: o,
        field: a,
        ...typeof t.gridProps.clipboard != "boolean" ? t.gridProps.clipboard : {},
        ...n
      }, l = V(), f = Bt({
        event: d,
        data: l,
        selectedState: (m = t.gridProps.select) != null ? m : {},
        previousCopiedItems: ye.current
      });
      e !== me.paste && (ye.current = f.copiedItems), t.gridProps.onClipboard && E && u(t.gridProps.onClipboard, {
        ...d,
        ...f
      });
    },
    [
      t.gridProps.select,
      t.gridProps.dataItemKey,
      t.gridProps.data,
      t.gridProps.clipboard,
      t.gridProps.onClipboard
    ]
  ), It = () => {
    var a, d, l;
    if (!$)
      return !1;
    const e = zt(v()), r = e ? e.matches(".k-table-td") ? e : (a = v()) == null ? void 0 : a.body : (d = v()) == null ? void 0 : d.body, n = r.closest(".k-grid-container"), o = r && ((l = K.current) == null ? void 0 : l.contains(r));
    return !!(r && o && n);
  }, Rt = (e, r, n, o, a, d) => {
    p(), X.current = !0, ae.current = !0, t.gridProps.onColumnResize && E && u(t.gridProps.onColumnResize, {
      columns: z(),
      nativeEvent: o,
      targetColumnId: d,
      index: e,
      newWidth: r,
      oldWidth: n,
      end: a,
      target: R.current
    });
  }, Ct = () => {
    var e;
    return {
      filter: t.gridProps.filter,
      sort: t.gridProps.sort,
      skip: t.gridProps.skip,
      take: (e = t.gridProps.take) != null ? e : t.gridProps.pageSize,
      group: t.gridProps.group
    };
  }, h = (e) => ({
    nativeEvent: e && e.nativeEvent,
    syntheticEvent: e,
    target: R.current
  }), vt = (e) => ({
    ...e,
    nativeEvent: void 0,
    syntheticEvent: void 0,
    target: void 0,
    targetEvent: void 0,
    focusElement: void 0
  }), u = (e, r) => {
    if (t.gridProps.isClient) {
      e(r);
      return;
    }
    e(vt(r));
  }, Et = () => {
    var e, r, n;
    if (H.current && ((e = H.current) == null ? void 0 : e.getElementsByClassName("k-grid-edit-row").length) > 0) {
      ce.current = !1, (r = document.activeElement) != null && r.closest(".k-grid-edit-row") ? de.current = document.activeElement : de.current = void 0;
      const o = Array.from((n = H.current) == null ? void 0 : n.getElementsByClassName("k-grid-edit-row"));
      o.length > ge.current.length ? q.current = o.filter(
        (a) => !ge.current.includes(a)
      )[0] : o.length === 1 && (q.current = o[0], ce.current = !0), ge.current = o;
    }
  }, U = () => t.dataRef.filter((e) => e.rowType === "data").map((e) => e.dataItem), V = () => (t.slicedData || t.dataRef).filter((e) => e.rowType === "data").map((e) => e.dataItem), ee = () => (oe.current || (oe.current = Ot() || void 0), oe.current), v = () => {
    var e;
    if ($)
      return ((e = W()) == null ? void 0 : e.ownerDocument) || document;
  }, W = () => K.current, te = i.useCallback(
    (e) => {
      var o;
      if (!c.current || !((o = c.current) != null && o.container) || t.gridProps.scrollable === "none")
        return;
      k.current && k.current.disconnect();
      const { rowIndex: r } = e, n = W();
      if (t.gridProps.scrollable === "virtual")
        c.current.askedSkip = r, c.current.container.scroll(
          0,
          Math.round(c.current.askedSkip / c.current.total * c.current.container.scrollHeight)
        );
      else if (n) {
        const a = r < 1 ? n.querySelector("tbody > tr:nth-child(1)") : n.querySelector(`tbody > tr:nth-child(${r + 1})`);
        a && j.current && (j.current.scrollTop = a.offsetTop);
      }
    },
    [t.gridProps.scrollable]
  ), Ee = (e) => JSON.stringify(e.map((r) => ({ id: r.id, field: r.field, title: r.title, children: r.children }))), wt = () => Ee(At) === Ee(g.current), yt = () => {
    wt() || re();
  }, xt = () => {
    const { data: e, total: r } = t.gridProps;
    return Array.isArray(e) ? e.length === r : e ? r === e.total : !1;
  }, St = (e, r) => {
    var n, o;
    if (c.current) {
      if (c.current.fixedScroll = t.gridProps.fixedScroll || !1, c.current.PageChange = O, c.current.realSkip = t.gridProps.skip || 0, c.current.pageSize = (o = (n = t.gridProps.take) != null ? n : t.gridProps.pageSize) != null ? o : 0, c.current.scrollableVirtual = t.gridProps.scrollable === "virtual", c.current.total = e, c.current.propsSkip = (t.gridProps.skip || 0) + (t.gridProps.scrollable === "virtual" ? c.current.topCacheCount + (c.current.attendedSkip - (t.gridProps.skip || 0)) : 0), t.gridProps.rowHeight !== void 0 && t.gridProps.rowHeight > 0 && !r) {
        const a = t.gridProps.rowHeight * e;
        c.current.containerHeight = Oe ? Math.min(Be, a) : a;
      } else
        c.current.containerHeight = 1533915;
      if (c.current.containerRef = j, c.current.tableBodyRef = H, c.current.table = x.current, c.current instanceof Ue) {
        const { rowHeight: a = 0, detail: d, expandField: l } = t.gridProps;
        let { detailRowHeight: f = 0 } = t.gridProps;
        f = d && l ? f : a, xt() ? (c.current.total = t.dataRef.length, c.current.rowHeightService = new Le(
          t.dataRef.length,
          a,
          f,
          t.dataRef
        )) : c.current.rowHeightService = new Le(e, a, f);
        const m = c.current.rowHeightService.totalHeight();
        c.current.containerHeight = Oe ? Math.min(Be, m) : m;
      }
    }
  }, Dt = () => {
    const e = (n) => n.map((o) => ({
      id: o.id,
      field: o.field,
      title: o.title,
      hidden: !1,
      children: o.children ? e(o.children) : null
    })), r = t.columnsRef.current.filter((n) => n.depth === 0);
    return e(r);
  }, we = i.useCallback(
    (e) => {
      const r = { rowIndex: ue.current };
      e.forEach((n) => {
        n.isIntersecting || te(r);
      });
    },
    [te]
  ), re = () => {
    t.gridProps.forceUpdate && t.gridProps.forceUpdate();
  }, kt = (e) => e.left !== void 0 ? xe !== "rtl" ? { left: e.left, right: e.right } : { left: e.right, right: e.left } : {}, R = i.useRef(null), g = t.columnsRef, c = i.useRef(), w = i.useRef(), S = i.useRef(), y = i.useRef(), D = i.useRef(), _ = i.useRef(), k = i.useRef(null), H = i.useRef(null), Kt = i.useRef(null), j = i.useRef(null), x = i.useRef(null), ne = i.useRef(null), K = i.useRef(null), F = i.useRef(null), L = i.useRef(null), oe = i.useRef(), ae = i.useRef(!1), ie = i.useRef(!1), q = i.useRef(), de = i.useRef(), ce = i.useRef(!1), X = i.useRef(!0), le = i.useRef(0), se = i.useRef(), ue = i.useRef(), ge = i.useRef([]), ye = i.useRef([]), G = i.useRef(null), Tt = i.useRef(null), Mt = i.useRef(null), xe = Nt(K), At = i.useMemo(() => i.Children.toArray(t.gridProps.children), [t.gridProps.children]), I = Y((ke = t.gridProps.selectable) != null ? ke : !!t.gridProps.selectedField), Se = Ut((Ke = t.gridProps.editable) != null ? Ke : !!t.gridProps.editField);
  i.useMemo(() => {
    T.onConstructor({
      navigatable: !!t.gridProps.navigatable,
      contextStateRef: y,
      navigationStateRef: D,
      idPrefix: t.id
    });
  }, []), i.useMemo(() => {
    var n;
    (n = c.current) == null || n.reset();
    const e = t.gridProps.groupable === !0 || typeof t.gridProps.groupable == "object" && t.gridProps.groupable.enabled !== !1, r = t.isFixedVirtualScroll ? Ue : lr;
    c.current = new r(e || t.gridProps.rowHeight === void 0 || t.gridProps.rowHeight === 0);
  }, [
    t.gridProps.scrollable,
    t.gridProps.total,
    t.gridProps.filter,
    t.gridProps.group,
    t.gridProps.groupable,
    t.gridProps.sort,
    t.gridProps.rowHeight
  ]), i.useEffect(() => (t.gridProps.clipboard && (_.current = new Vt(B), _.current.addEventListeners(v())), () => {
    _.current && _.current.removeEventListeners(v());
  }), [t.gridProps.onClipboard, t.gridProps.clipboard, B, v]), i.useEffect(() => (t.gridProps.columnVirtualization && !window.navigator.userAgent.match(nr) && (ne.current && (ne.current.style.display = "block"), x.current && (x.current.style.display = "block")), p(), Fe(ee()), T.onComponentDidMount({
    scope: K.current || void 0,
    contextStateRef: y,
    navigationStateRef: D
  }), () => {
    clearTimeout(se.current);
  }), []), i.useEffect(() => {
    var e;
    p(), Fe(ee()), (e = c.current) != null && e.tableTransform && c.current.table && (c.current.table.style.transform = c.current.tableTransform, c.current.tableTransform = ""), Et(), T.onComponentDidUpdate({
      scope: K.current || void 0,
      contextStateRef: y,
      navigationStateRef: D,
      focusFirst: ie.current,
      newEditableRow: q.current,
      singleEditRow: ce.current,
      lastActiveElement: de.current,
      navigatable: t.gridProps.navigatable
    }), ie.current = !1, q.current = void 0;
  }), i.useEffect(() => {
    if ($) {
      const e = {
        rootMargin: "0px",
        threshold: 0.9
      };
      k.current = window.IntersectionObserver && new window.IntersectionObserver(we, e) || null;
    }
  }, [we]), i.useEffect(() => {
    var r;
    let e;
    return $ && window.ResizeObserver && (e = new window.ResizeObserver(yt), e.observe((r = v()) == null ? void 0 : r.body)), () => {
      e == null || e.disconnect();
    };
  }, []), i.useImperativeHandle(
    R,
    () => ({
      get element() {
        return W();
      },
      props: t.gridProps,
      get columns() {
        return z();
      },
      scrollIntoView: (e) => {
        var o;
        if (!((o = c.current) != null && o.container) || t.gridProps.scrollable === "none")
          return;
        const { rowIndex: r } = e;
        ue.current = r;
        const n = W();
        if (k.current && n) {
          k.current.disconnect();
          const a = n.querySelector(`[absolute-row-index="${ue.current}"]`);
          a ? k.current.observe(a) : te(e);
        }
      },
      fitColumns: (e) => {
        w.current.dblClickHandler(null, e);
      }
    })
  ), i.useImperativeHandle(t.gridRef, () => R.current), i.useMemo(() => {
    w.current = new tr(Rt);
  }, [t.gridProps.onColumnResize]), i.useMemo(() => {
    S.current = new rr(Z, ht, ve);
  }, [
    t.gridProps.onColumnReorder,
    t.gridProps.onGroupChange,
    t.gridProps.group,
    t.gridProps.groupable
  ]), w.current.resizable = t.gridProps.resizable || !1, w.current.columns = g.current;
  const De = t.gridProps.groupable === !0 || typeof t.gridProps.groupable == "object" && t.gridProps.groupable.enabled !== !1;
  S.current.reorderable = t.gridProps.reorderable || !1, S.current.groupable = De, S.current.columns = g.current, St(t.total, De);
  const Ht = t.gridProps.columnsState || Dt();
  return /* @__PURE__ */ i.createElement(
    fr.Provider,
    {
      value: {
        isClient: E,
        rowReorder: A,
        activeDragRowDataItemRef: G,
        reorderRowDragTargetRef: Tt,
        reorderRowDropTargetRef: Mt,
        dir: xe,
        getCellPositionStyle: kt,
        dataItemKey: t.gridProps.dataItemKey,
        columnsState: Ht,
        onColumnsStateChange: Pt,
        groupChange: Q,
        selectionRelease: at,
        pagerPageChange: gt,
        onContextMenu: qe,
        rowClick: Qe,
        rowDblClick: Ze,
        cellClick: pe,
        headerCellClick: Re,
        itemChange: rt,
        sortChange: Ce,
        filterChange: ft,
        searchChange: mt,
        onHeaderSelectionChange: ot,
        columnGroupChange: bt,
        onKeyDown: $e,
        onFocus: Je,
        scrollHandler: Xe,
        selectionChange: nt,
        dispatchDetailExpand: et,
        dispatchGroupExpand: tt,
        columnResizeRef: w,
        dragLogicRef: S,
        navigationStateRef: D,
        tableElementRef: x,
        tableBodyElementRef: H,
        headerElementRef: Kt,
        containerElementRef: j,
        headTableElementRef: ne,
        elementRef: K,
        footerRef: F,
        headerRef: L,
        getCachedScrollbarWidth: ee,
        vsRef: c
      }
    },
    /* @__PURE__ */ i.createElement(Wt.Provider, { value: y.current }, t.children),
    /* @__PURE__ */ i.createElement(
      sr,
      {
        show: b.show,
        dataItem: b.dataItem,
        field: b.field,
        items: _e,
        offset: b.offset,
        onClose: he,
        onSelect: je
      }
    )
  );
};
export {
  Sr as GridClientWrapper,
  fr as GridContext
};
