/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as y from "react";
import { gridDefaultProps as b } from "../GridColumn.mjs";
import { getter as u } from "@progress/kendo-data-query";
import { findGroupExpand as A, updateLeft as E, updateRight as M, tableKeyboardNavigationTools as m } from "@progress/kendo-react-data-tools";
import { ServerFragment as D } from "./_serverModule.mjs";
import { ClientFragment as T } from "./_clientModule.mjs";
import { GridContextMenuItemNames as g } from "../contextMenu/enums.mjs";
function w(e, t) {
  const n = (e != null ? e : "").split(".");
  let i = t;
  return n.forEach((l) => {
    i = i ? i[l] : void 0;
  }), i;
}
function B(e, t, n, i, l, f, r, a, d, o, s = 0, c) {
  var v;
  let C = s;
  for (let h = 0; h < t.length; h++) {
    let S;
    if (!l || t[h].value === void 0 || t[h].items === void 0) {
      e[e.length] = {
        dataIndex: i.index,
        dataItem: t[h],
        rowType: "data",
        level: s,
        group: c,
        // This is related to detail-row expansion
        expanded: (v = f ? w(f, t[h]) : o && !!(r != null && r[u(o)(t[h])])) != null ? v : !1
      }, i.index++;
      continue;
    } else {
      let I;
      c != null && c.parents ? I = [{ field: c.field, value: c.value }, ...c.parents] : c ? I = [c] : I = [], S = {
        field: t[h].field,
        value: t[h].value,
        parents: I
      };
    }
    C = Math.max(C, s + 1);
    let x = !1;
    if (f)
      x = w(f, t[h]) !== !1;
    else {
      const I = A(a || [], S);
      I ? x = I.expanded !== !1 : x = d !== !1;
    }
    e[e.length] = {
      dataIndex: -1,
      dataItem: t[h],
      level: s,
      group: S,
      rowType: "groupHeader",
      expanded: x
    }, x && (S.expanded = x, C = Math.max(
      B(
        e,
        t[h].items,
        n,
        i,
        l,
        f,
        r,
        a,
        d,
        o,
        s + 1,
        S
      ),
      C
    )), (n === "always" || x && n === "visible") && (e[e.length] = {
      dataIndex: -1,
      dataItem: t[h],
      rowType: "groupFooter",
      level: s,
      expanded: x
    });
  }
  return C;
}
const z = (e, t) => typeof e.colSpan == "function" ? e.colSpan({ dataItem: t, column: e }) : e.colSpan || 1;
function W(e, t) {
  const n = [[]];
  let i = 0;
  for (let r = e.length - 1; r >= 0; r--)
    i = Math.max(i, e[r].depth), e[r].headerColSpan = e[r].headerColSpan || 1, e[r].children.length > 0 && (e[r].headerColSpan = e[r].children.reduce(
      (a, d) => d.hidden ? a : a + d.headerColSpan,
      0
    ));
  const l = [];
  let f = 1;
  return e.forEach((r, a) => {
    n[r.depth] = n[r.depth] || [];
    let d = !1;
    n[r.depth].length === 0 && (f <= 1 ? f = 1 + (r.children.length > 0 ? 0 : i - r.depth) : (f--, d = !0)), r.rowSpan = 1 + (r.children.length > 0 ? 0 : i - r.depth), r.kFirst = d, r.index = n[r.depth].length, n[r.depth].push(a), r.ariaColumnIndex = l[r.depth] ? l[r.depth] + 1 : 1;
    for (let o = r.depth; o < r.depth + r.rowSpan; o++)
      l[o] = (l[o] || 0) + r.headerColSpan;
  }), E(n, e, t), M(n, e, t), n;
}
function j(e, t, n, i = 0) {
  const l = [];
  if (!e)
    return [];
  e && e.length === void 0 && (e = [e]), e.filter((a) => a && a.props ? !a.props.hidden : !a.hidden).forEach((a, d) => {
    a = a.props ? a.props : a;
    const o = t[d] || null, s = j(
      a.children,
      o && o.children || [],
      n,
      i + 1
    );
    l.push(
      Object.assign(
        { depth: i },
        b,
        s.length ? { cell: () => null, filterCell: () => null } : {},
        o ? { width: o.width, orderIndex: o.orderIndex } : {},
        a,
        {
          id: a.id ? a.id : m.generateNavigatableId(`${n.prevId++}`, n.idPrefix, "column"),
          declarationIndex: l.length,
          children: s,
          headerColSpan: a.headerColSpan,
          rowSpan: 0,
          columnType: a.columnType || "data",
          colSpan: a.colSpan || 1,
          isAccessible: !0,
          left: a.lockedColumn ? o && Math.floor(o.left) : null,
          right: a.lockedColumn ? o && Math.floor(o.right) : null,
          rowSpannable: a.rowSpannable
        }
      )
    );
  });
  const r = (a, d) => a.orderIndex === d.orderIndex ? a.declarationIndex - d.declarationIndex : (a.orderIndex || 0) - (d.orderIndex || 0);
  if (l.sort(r), i === 0) {
    const a = [], d = (o, s) => o.forEach((c) => {
      c.parentIndex = s, d(c.children, a.push(c) - 1);
    });
    return d(l, -1), a;
  }
  return l;
}
const k = (e) => Array.isArray(e) ? e : e ? e.data : [];
function J(e, t, n, i) {
  const l = k(e), f = [];
  if (l.length > 0) {
    let r = l[0];
    if (t)
      for (let d = 0; d < t.length; d++)
        r = r.items && r.items[0];
    Object.getOwnPropertyNames(r).forEach((d) => {
      d !== n.column && f.push(
        Object.assign(
          {
            id: m.generateNavigatableId(`${i.prevId++}`, i.idPrefix, "column"),
            declarationIndex: -1,
            parentIndex: -1,
            depth: 0,
            colSpan: 0,
            headerColSpan: 0,
            rowSpan: 0,
            index: 0,
            columnType: "data",
            left: 0,
            right: 0,
            rightBorder: !1,
            children: [],
            ariaColumnIndex: 0,
            isAccessible: !0
          },
          b,
          { field: d }
        )
      );
    });
  }
  return f;
}
const p = (e, t) => {
  let n = e[t.parentIndex];
  for (; n; ) {
    if (n.footerCell)
      return !0;
    n = e[n.parentIndex];
  }
  return !1;
}, K = (e) => e.filter((t) => p(e, t) ? !1 : !!t.footerCell || !(t.children && t.children.length > 0)), Q = (e) => e.width !== void 0 ? Math.floor(parseFloat(e.width.toString())) + "px" : void 0, U = (e, t) => t && t.filter((n) => n.field === e).length > 0, F = (e) => (e.sort((t, n) => t.declarationIndex - n.declarationIndex), e.map((t) => {
  const { declarationIndex: n, parentIndex: i, depth: l, headerColSpan: f, rowSpan: r, index: a, kFirst: d, children: o, ...s } = t;
  return o.length ? {
    children: F(o),
    ...s
  } : s;
})), R = (e) => {
  const { filterCell: t, headerCell: n, footerCell: i, cells: l, cell: f, rowSpannable: r, ...a } = e;
  return e.children.length ? {
    ...a,
    children: e.children.map(R)
  } : a;
}, X = typeof window != "undefined" && /Firefox/.test(window.navigator.userAgent), Y = 17895697, Z = (e) => {
  let t = [];
  return e.sortable && (t = t.concat([g.sortAsc, g.sortDesc])), t;
}, _ = (e) => {
  let t = [];
  return e.clipboard && (t = t.concat([
    g.copySelection,
    g.copySelectionNoHeaders,
    g.paste
  ])), e.editable && (t.length && (t = t.concat([g.separator])), t = t.concat([
    g.create,
    g.edit,
    g.delete
  ])), e.selectable && (t.length && (t = t.concat([g.separator])), t = t.concat([g.select])), e.rowReorderable && (t.length && (t = t.concat([g.separator])), t = t.concat([g.reorderRow])), t;
}, G = (e, t) => {
  if (!(!e && !t))
    return t ? e ? {
      ...e,
      ...t,
      select: {
        ...e.select || {},
        ...t.select || {}
      },
      hierarchy: {
        ...e.hierarchy || {},
        ...t.hierarchy || {}
      },
      group: {
        ...e.group || {},
        ...t.group || {}
      },
      edit: {
        ...e.edit || {},
        ...t.edit || {}
      }
    } : t : e;
}, P = (e) => {
  var n;
  return typeof e == "object" ? (n = e.enabled) != null ? n : !0 : e != null ? e : !1;
}, ee = () => D === T, te = (e) => !!(e && e.$$typeof === Symbol.for("react.client.reference")), re = (e) => ({
  id: e.id,
  ariaColumnIndex: e.ariaColumnIndex,
  isSelected: e.isSelected,
  isInEdit: e.isInEdit,
  isSorted: e.isSorted,
  isAlt: e.isAlt,
  expanded: e.expanded,
  className: e.className,
  style: e.style,
  field: e.field,
  dataItem: e.dataItem,
  format: e.format,
  colSpan: e.colSpan,
  dataIndex: e.dataIndex,
  columnIndex: e.columnIndex,
  columnsCount: e.columnsCount,
  rowType: e.rowType,
  level: e.level,
  editor: e.editor,
  render: e.render,
  locked: e.locked,
  isRtl: e.isRtl,
  rowDataIndex: e.rowDataIndex,
  columnPosition: e.columnPosition,
  group: e.group
}), ne = (e) => {
  var i, l;
  const t = typeof e == "object" ? (i = e.enabled) != null ? i : !0 : e != null ? e : !1, n = typeof e == "object" ? (l = e.valueGetter) != null ? l : (f, r) => u(r)(f) : (f, r) => u(r)(f);
  return { enabled: t, valueGetter: n };
}, N = (e) => {
  var t;
  return y.isValidElement(e) ? e : (t = y.Children.toArray(e)) == null ? void 0 : t[0];
}, ae = (e, t) => {
  const n = N(e);
  return n ? y.cloneElement(n, t) : null;
};
export {
  J as autoGenerateColumns,
  R as clientColumn,
  ae as cloneReactElement,
  X as firefox,
  Y as firefoxMaxHeight,
  B as flatData,
  K as footerColumns,
  re as getClientCellProps,
  z as getColSpan,
  Q as getColumnWidth,
  k as getDataAsArray,
  _ as getDefaultBodyContextMenuItems,
  Z as getDefaultHeadContextMenuItems,
  w as getNestedValue,
  N as getReactElement,
  ne as getRowSpanOptions,
  ee as isClient,
  te as isClientReference,
  P as isRowReorderEnabled,
  U as isSorted,
  W as mapColumns,
  j as readColumns,
  G as resolveCells,
  F as sanitizeColumns
};
