/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as l from "react";
import { validatePackage as wt, uGrid as Et, getter as H, classNames as f, canUseDOM as It } from "@progress/kendo-react-common";
import { process as St } from "@progress/kendo-data-query";
import { combineFilters as vt, getDetailExpandableOptions as Rt, getGroupExpandableOptions as xt, getSelectionOptions as Gt, tableKeyboardNavigationTools as ee, Pager as kt, tableKeyboardNavigationBodyAttributes as Nt, tableKeyboardNavigationScopeAttributes as Ke, tableColumnsVirtualization as Ft } from "@progress/kendo-react-data-tools";
import { GridSelectionCell as Dt } from "./cells/GridSelectionCell.mjs";
import { GridHierarchyCell as Tt } from "./cells/GridHierarchyCell.mjs";
import { GridEditCell as Ht } from "./cells/GridEditCell.mjs";
import { Header as Kt } from "./header/Header.mjs";
import { HeaderRow as At } from "./header/HeaderRow.mjs";
import { FilterRow as Bt } from "./header/FilterRow.mjs";
import { GroupPanel as Pt } from "./header/GroupPanel.mjs";
import { Footer as Vt } from "./footer/Footer.mjs";
import { isRowReorderEnabled as Lt, getRowSpanOptions as Ae, getColumnWidth as te, isSorted as Be, flatData as Ot, autoGenerateColumns as _t, mapColumns as zt, clientColumn as Mt, getNestedValue as Pe, getColSpan as Ve, resolveCells as Wt, isClientReference as jt, sanitizeColumns as $t, readColumns as Ut } from "./utils/index.mjs";
import { GridCell as Jt } from "./cells/GridCell.mjs";
import { GridGroupCell as Le } from "./cells/GridGroupCell.mjs";
import { GridRow as Qt } from "./rows/GridRow.mjs";
import { GridHeaderSelectionCell as Xt } from "./header/GridHeaderSelectionCell.mjs";
import { GridNoRecords as Oe } from "./components/noRecords/GridNoRecords.mjs";
import { operators as _e } from "./filterCommon.mjs";
import { FooterRow as Yt } from "./footer/FooterRow.mjs";
import { normalize as Zt } from "./paging/GridPagerSettings.mjs";
import { packageMetadata as qt } from "./package-metadata.mjs";
import { GridDetailCell as pt } from "./cells/GridDetailCell.mjs";
import { GridDetailHierarchyCell as el } from "./cells/GridDetailHierarchyCell.mjs";
import { GridNoRecordsContainer as ze } from "./components/noRecords/GridNoRecordsContainer.mjs";
import { GridWatermarkOverlay as tl } from "./GridWatermarkOverlay.mjs";
import { GridClientWrapper as Me } from "./GridClientWrapper.mjs";
import { GridColGroup as ll } from "./components/colGroup/GridColGroup.mjs";
import { GridTable as al } from "./components/table/GridTable.mjs";
import { GridDropClue as We } from "./components/GridDropClue.mjs";
import { GridDragClue as je } from "./components/GridDragClue.mjs";
import { GridTableBody as $e } from "./components/table/GridTableBody.mjs";
import { PagerContainer as rl } from "./components/PagerContainer.mjs";
import { GridTableScrollable as nl } from "./components/table/GridTableScrollable.mjs";
import { GridElementContainer as Ue } from "./components/GridElementContainer.mjs";
import { GridContainerElementContainer as il } from "./components/GridContainerElementContainer.mjs";
import { VirtualScrollHeightContainer as ol } from "./components/VirtualScrollHeightContainer.mjs";
import { LocalizationService as dl, IntlService as cl } from "@progress/kendo-react-intl";
import { gridAriaLabel as Je, messages as sl } from "./messages/index.mjs";
import { VirtualScrollFixed as j } from "./VirtualScrollFixed.mjs";
import { VirtualScroll as ml } from "./VirtualScroll.mjs";
import { GridCustomCellClientContainer as ul } from "./components/GridCustomCellClientContainer.mjs";
import { GridReorderableRowsContainer as fl } from "./components/GridDraggableRowsContainer.mjs";
import { GridRowReorderCell as gl } from "./cells/GridRowReorderCell.mjs";
import { GridHeaderRowReorderCell as bl } from "./header/client/GridHeaderRowReorderCell.mjs";
import { GridLoader as Qe } from "./components/GridLoader.mjs";
const hl = l.forwardRef((e, le) => {
  var Se, ve, Re, xe, Ge, ke, Ne;
  const R = e.id + "-role-element-id", x = e.navigatable ? R : "";
  wt(qt);
  const Xe = (t, r, d, o, i, a, c) => {
    const s = [], h = Ot(
      s,
      C,
      t,
      { index: r },
      d !== void 0,
      o,
      i,
      a,
      ot.defaultExpand,
      c
    );
    return { flattedData: s, resolvedGroupsCount: h };
  }, Ye = (t) => {
    const r = t.filter(
      (i) => i && i.type && i.type.displayName === "KendoReactGridColumn"
    ), d = m.current.filter((i) => i.declarationIndex >= 0 && i.parentIndex === -1), o = $t(d);
    return Ut(r, o, { prevId: 0, idPrefix: x });
  }, Ze = (t) => t.filter((r) => It && r && r.media ? window.matchMedia(r.media).matches : r), qe = () => {
    const t = [], r = (d, o) => d == null ? void 0 : d.forEach((i) => {
      const a = i.hidden || o;
      t.push({
        ...i,
        hidden: a
      }), r(i.children, a);
    });
    return r(e.columnsState, !1), t;
  }, pe = (t) => {
    const r = qe();
    return t.filter((d) => {
      var o;
      return !((o = r.find((i) => i.id === d.id)) != null && o.hidden);
    });
  }, et = (t, r) => {
    var i;
    const d = Ye(t), o = Ze(d);
    m.current = o, m.current.length === 0 && (m.current = _t(
      C,
      e.group,
      {
        column: (i = A.column) != null ? i : e.expandField
      },
      {
        prevId: 0,
        idPrefix: x
      }
    )), m.current = pe(m.current), tt(m.current, r), G = zt(m.current, !0), re.current = m.current.map(Mt);
  }, tt = (t, r) => {
    var i;
    t.filter((a) => e.selectedField && a.field === e.selectedField || a.columnType === "checkbox").forEach((a) => {
      a.width = a.width || "50px", a.cell = a.cell || Dt, a._type = "edit", a.headerCell = a.headerCell || Xt;
    }), N !== void 0 && t.filter((a) => a.columnType === "reorder").forEach((a) => {
      a.width = a.width || "50px", a.cell = a.cell || gl, a.headerCell = a.headerCell || bl, a.sortable = !1, a.filterable = !1, a.editable = !1;
    });
    const d = {
      id: "",
      resizable: !0,
      width: "32px",
      title: " ",
      declarationIndex: -1,
      orderIndex: -1,
      children: [],
      parentIndex: -1,
      depth: 0,
      colSpan: 0,
      headerColSpan: 0,
      rowSpan: 0,
      left: 0,
      right: 0,
      index: 0,
      rightBorder: !1,
      ariaColumnIndex: 0,
      isAccessible: !0
    };
    let o = 0;
    (e.expandField || A.enabled) && e.detail && (t.unshift({
      ...d,
      _type: "expand",
      cell: Tt,
      field: (i = A.column) != null ? i : e.expandField,
      headerClassName: f(u.hierarchyCell({}))
    }), o++);
    for (let a = 0; a < r; a++)
      t.unshift({
        ...d,
        isAccessible: !1,
        cell: Le,
        field: "value",
        locked: e.lockGroups
      }), o++;
    t.slice(o).forEach((a) => {
      a.parentIndex >= 0 && (a.parentIndex += o), a.rowSpannable = a.rowSpannable !== void 0 ? Ae(a.rowSpannable) : ie;
    });
  }, ae = () => C.length === e.total, lt = () => {
    const { rowHeight: t, detailRowHeight: r, detail: d, expandField: o } = e, i = ae(), a = t !== void 0 && t > 0, c = r !== void 0 && r > 0;
    return !a || K && !i || !!(d && o) && (!c || !i) ? ml : j;
  }, $ = () => e.isClient ? m : re, at = (t, r, d, o, i, a) => {
    let c = Ve(t, r);
    if (e.columnVirtualization && t.colSpan === 1)
      return { colSpan: a, colsToSkip: i };
    let s = d.length - 1 === o, h = d.length - o;
    return e.columnVirtualization && (s = b.length - 1 === o, h = b.length - o), c > 1 && !s ? i = c - 1 : c = 1, h <= c && !s && (c = h), { colSpan: c, colsToSkip: i };
  };
  let U, g = [], O;
  const m = e.columnsRef || { current: [] }, re = { current: [] };
  let G = [[]];
  const rt = e.scrollLeftRef || { current: 0 }, _ = e.localization || new dl(), nt = e.intl || new cl("en"), k = e.unstyled, u = k && k.uGrid ? k.uGrid : Et, N = Lt(e.rowReorderable), F = e.autoProcessData === !0 ? {
    group: !0,
    sort: !0,
    filter: !0,
    search: !0,
    page: !0
  } : e.autoProcessData;
  let C, v;
  if (Array.isArray(e.data) ? (C = e.data, v = (Se = e.total) != null ? Se : C.length) : (C = ((ve = e.data) == null ? void 0 : ve.data) || [], v = (Ge = (xe = e.total) != null ? xe : (Re = e.data) == null ? void 0 : Re.total) != null ? Ge : C.length), F) {
    const { data: t, total: r } = St(C, {
      group: F.group ? e.group : void 0,
      sort: F.sort ? e.sort : void 0,
      filter: vt(
        F.filter ? e.filter : void 0,
        F.search ? e.search : void 0
      ),
      ...F.page ? {
        take: e.take,
        skip: e.skip
      } : {}
    });
    C = t, v = (ke = e.total) != null ? ke : r;
  }
  const { size: E = "medium" } = e, it = typeof e.groupable == "object" && e.groupable.footer || "none", D = e.scrollable === "virtual", K = e.groupable === !0 || typeof e.groupable == "object" && e.groupable.enabled !== !1, A = Rt(!!e.detail), ot = xt(
    typeof e.groupable == "object" && e.groupable.enabled !== !1 ? e.groupable.expandable : e.groupable
  ), { resolvedGroupsCount: dt, flattedData: ct } = Xe(
    it,
    e.skip || 0,
    e.group,
    e.expandField,
    e.detailExpand,
    e.groupExpand,
    e.dataItemKey
  );
  g = ct;
  const J = lt();
  J === j && ae() && (O = g.slice(
    e.skip || 0,
    (e.skip || 0) + ((e.take !== void 0 ? e.take : e.pageSize) || 0)
  ));
  const ne = Gt(e.selectable || !!e.selectedField), ie = Ae(e.rowSpannable), st = ne && ne.drag ? "none" : void 0, z = l.Children.toArray(e.children);
  et(z, dt);
  const oe = z.map((t) => t && t.type && t.type.displayName === "KendoReactGridToolbar" ? l.cloneElement(t, { ...t.props, ariaControls: R }) : null), M = z.filter((t) => t && t.type && t.type.displayName === "KendoReactGridNoRecords"), de = z.filter(
    (t) => t && t.type && t.type.displayName === "KendoReactGridStatusBar"
  ), b = m.current.filter((t) => t.children.length === 0), ce = K && /* @__PURE__ */ l.createElement(Pt, { columns: $().current, group: e.group || [], ariaControls: R }), se = /* @__PURE__ */ l.createElement(
    Kt,
    {
      size: E,
      staticHeaders: e.scrollable !== "none",
      draggable: e.reorderable || K,
      headerRow: /* @__PURE__ */ l.createElement(
        At,
        {
          cells: e.cells,
          sort: e.sort,
          sortable: e.sortable,
          group: e.group || [],
          groupable: K,
          filter: e.filter,
          filterable: e.filterable,
          filterOperators: e.filterOperators || _e,
          columnMenu: e.columnMenu,
          columnMenuIcon: e.columnMenuIcon,
          columns: m.current,
          columnsMap: G,
          cellRender: e.headerCellRender,
          navigatable: !!e.navigatable,
          localization: _,
          unstyled: k,
          headerSelectionValue: !!(e.select && g.filter((t) => t.rowType === "data").every(
            (t) => e.select && e.dataItemKey && H(e.dataItemKey)(t.dataItem) !== void 0 ? e.select[H(e.dataItemKey)(t.dataItem)] : void 0
          ))
        }
      ),
      filterRow: e.filterable && /* @__PURE__ */ l.createElement(
        Bt,
        {
          cells: e.cells,
          size: E,
          columns: m.current,
          filter: e.filter,
          filterOperators: e.filterOperators || _e,
          sort: e.sort,
          cellRender: e.filterCellRender,
          navigatable: !!e.navigatable,
          ariaRowIndex: G.length + 1,
          localization: _
        }
      ) || void 0,
      cols: b.map((t, r) => /* @__PURE__ */ l.createElement("col", { key: r.toString(), width: te(t) }))
    }
  ), mt = rt.current || 0, ut = parseFloat(((e.style || {}).width || "").toString()), ft = (t, r, d, o, i) => {
    let a = !1;
    const c = e.selectedField ? Pe(e.selectedField, t.dataItem) : e.select && e.dataItemKey && H(e.dataItemKey)(t.dataItem) !== void 0 ? e.select[H(e.dataItemKey)(t.dataItem)] : void 0;
    let s = 0;
    const { colSpans: h, hiddenColumns: T } = Ft({
      enabled: e.columnVirtualization,
      columns: b,
      tableViewPortWidth: ut,
      scrollLeft: mt,
      getColSpan: Ve,
      dataItem: t.dataItem
    }), I = b.filter((n, y) => !T[y]);
    return {
      row: b.map((n, y) => {
        var Fe, De, Te, He;
        if (T[y])
          return null;
        if (s > 0)
          return s--, null;
        let w;
        if ((Fe = n.rowSpannable) != null && Fe.enabled && t.rowType === "data" && n.field && i) {
          const S = n.field ? (Te = (De = n.rowSpannable).valueGetter) == null ? void 0 : Te.call(De, t.dataItem, n.field) : null;
          w = { value: S, count: 1 }, i[n.field] && ((He = i[n.field]) == null ? void 0 : He.value) === S && i[n.field] !== null ? (i[n.field].count++, w.count = null) : i[n.field] = w;
        }
        const { colSpan: P, colsToSkip: Y } = at(
          n,
          t.dataItem,
          I,
          y,
          s,
          h[y]
        );
        s = Y;
        const V = n.id ? n.id : y, ht = f(u.contentSticky({ locked: n.locked }), n.className), yt = n.left !== void 0 ? { left: n.left, right: n.right } : {};
        let Z = !1;
        if (n.editable && (e.editable || e.editField)) {
          const S = e.editField ? Pe(e.editField, t.dataItem) : e.edit && e.dataItemKey ? e.edit[H(e.dataItemKey)(t.dataItem)] : void 0, p = typeof S == "boolean" ? S : Array.isArray(S) ? S.indexOf(n.field) > -1 : n.field !== void 0 && S === n.field;
          p && n.columnType === "data" && (p === !0 || p === n.field) && (a = !0, Z = !0);
        }
        const q = n.cell || Z && Ht || Jt, Ct = e.expandField && e.detail && n.field === e.expandField || n._type === "expand", L = {
          locked: e.lockGroups,
          id: ee.generateNavigatableId(
            `${r}-${String(y)}`,
            x,
            Ct || t.rowType === "groupHeader" || t.rowType === "groupFooter" || n.field === "value" ? "nodata" : "cell"
          ),
          colSpan: P,
          dataItem: t.dataItem,
          field: n.field,
          editor: n.editor,
          format: n.format,
          columnType: n.columnType,
          rowReorderable: N,
          className: ht,
          render: e.cellRender,
          cells: Wt(e.cells, n.cells),
          columnIndex: y,
          columnsCount: b.length,
          rowType: t.rowType,
          level: t.level,
          expanded: t.expanded,
          dataIndex: t.dataIndex,
          rowDataIndex: d,
          columnPosition: yt,
          style: {},
          ariaColumnIndex: n.ariaColumnIndex,
          isSelected: (n == null ? void 0 : n._type) === "edit" ? c : Array.isArray(c) && c.indexOf(y) > -1,
          isSorted: !!Be(n.field, e.sort),
          isInEdit: Z,
          isAlt: o,
          unstyled: k,
          group: t.group,
          localization: _,
          intl: nt,
          _rowSpan: w
        };
        return n.cell ? /* @__PURE__ */ l.createElement(
          ul,
          {
            key: V,
            isClient: jt(q),
            dataItem: L.dataItem,
            rowDataIndex: L.rowDataIndex,
            columnIndex: L.columnIndex
          },
          /* @__PURE__ */ l.createElement(q, { ...L })
        ) : /* @__PURE__ */ l.createElement(q, { key: V, ...L });
      }),
      isInEdit: a,
      isSelected: typeof c == "boolean" && c
    };
  };
  let me = 0;
  if (D && U)
    for (let t = 0; t < U.topCacheCount + U.attendedSkip - (e.skip || 0); t++) {
      const r = g.shift();
      if (r)
        g.push(r), me++, r.rowType === "groupHeader" && t--;
      else
        break;
    }
  const ue = (t) => t >= g.length - me;
  let fe = e.skip || 0;
  const Q = [], ge = !g.length, be = G.length + (e.filterable ? 1 : 0) + 1;
  let B = 0;
  if (g.length) {
    let t = -1, r = 0;
    const d = ie.enabled ? {} : void 0;
    (O || g).forEach((o, i) => {
      o.rowType === "data" && (fe++, t++);
      const a = fe % 2 === 0, c = e.dataItemKey && H(e.dataItemKey)(o.dataItem), s = i + (e.skip || 0), h = c || "ai" + s, T = h + "_1", I = ft(o, h, t, a, d);
      if (B = s + be + r, Q.push(
        /* @__PURE__ */ l.createElement(
          Qt,
          {
            key: h,
            dataItem: o.dataItem,
            isAltRow: a,
            isInEdit: I.isInEdit,
            rowType: o.rowType,
            isRowReorderable: N,
            isHidden: ue(i),
            onClick: null,
            onDoubleClick: null,
            selectedField: e.selectedField,
            rowHeight: e.rowHeight,
            render: e.rowRender,
            ariaRowIndex: B,
            absoluteRowIndex: s,
            dataIndex: D && !e.groupable ? s : t,
            isSelected: I.isSelected,
            rows: e.rows
          },
          I.row
        )
      ), e.detail && o.rowType === "data" && o.expanded) {
        const n = b.length - (e.expandField || A.enabled ? 1 : 0) - (e.group ? e.group.length : 0) || 1;
        r++, B = s + be + r, Q.push(
          /* @__PURE__ */ l.createElement(
            "tr",
            {
              key: T,
              className: f(u.detailTr({ isAlt: a })),
              style: {
                visibility: ue(i) ? "hidden" : "",
                height: e.detailRowHeight
              },
              role: "row",
              "aria-rowindex": B
            },
            e.group && e.group.map((y, w) => {
              var V;
              const P = (V = I == null ? void 0 : I.row[w]) == null ? void 0 : V.props.style, Y = P ? { left: P.left, right: P.right } : {};
              return /* @__PURE__ */ l.createElement(
                Le,
                {
                  id: "",
                  dataIndex: o.dataIndex,
                  field: y.field,
                  dataItem: o.dataItem,
                  key: w,
                  columnPosition: Y,
                  style: {},
                  ariaColumnIndex: 1 + w,
                  isSelected: !1,
                  locked: e.lockGroups,
                  cells: e.cells,
                  group: o.group
                }
              );
            }),
            (e.expandField || A.enabled) && /* @__PURE__ */ l.createElement(
              el,
              {
                unstyled: k,
                id: ee.generateNavigatableId(`${T}-dhcell`, x)
              }
            ),
            /* @__PURE__ */ l.createElement(
              pt,
              {
                dataItem: o.dataItem,
                dataIndex: o.dataIndex,
                colSpan: n,
                ariaColIndex: 2 + (e.group ? e.group.length : 0),
                detail: e.detail,
                id: ee.generateNavigatableId(`${T}-dcell`, x)
              }
            )
          )
        );
      }
    });
  }
  const he = {
    size: E,
    total: v,
    skip: e.skip || 0,
    take: (e.take !== void 0 ? e.take : e.pageSize) || 10,
    ...Zt(e.pageable || {})
  }, ye = /* @__PURE__ */ l.createElement(rl, null, e.pager ? /* @__PURE__ */ l.createElement(e.pager, { ...he }) : /* @__PURE__ */ l.createElement(kt, { className: f(u.pager({})), ...he })), gt = (t, r) => /* @__PURE__ */ l.createElement("col", { key: r.toString(), width: te(t) }), bt = (Ne = e.cells) != null && Ne.footerCell || m.current.some((t) => {
    var r;
    return !!(t.footerCell || (r = t.cells) != null && r.footerCell);
  }) ? /* @__PURE__ */ l.createElement(
    Vt,
    {
      size: E,
      staticHeaders: e.scrollable !== "none",
      row: /* @__PURE__ */ l.createElement(
        Yt,
        {
          cells: e.cells,
          idPrefix: x,
          columns: m.current,
          ariaRowIndex: B + 1
        }
      ),
      cols: b.map(gt)
    }
  ) : null, Ce = /* @__PURE__ */ l.createElement(ll, null, b.map((t, r) => /* @__PURE__ */ l.createElement(
    "col",
    {
      key: r.toString(),
      className: Be(t.field, e.sort) ? f(u.sorted({})) : void 0,
      width: te(t)
    }
  ))), we = e.reorderable || K, { detail: yl, cells: Cl, rows: wl, ...Ee } = e, Ie = /* @__PURE__ */ l.createElement(
    "tbody",
    {
      role: "rowgroup",
      className: f(u.tbody({})),
      ...Nt
    },
    Q
  );
  let X = Ie;
  if (N && (X = /* @__PURE__ */ l.createElement(
    fl,
    {
      unstyled: u,
      columns: m.current,
      rowReorderSettings: e.rowReorderable
    },
    Ie
  )), e.scrollable === "none")
    return /* @__PURE__ */ l.createElement(
      Me,
      {
        gridRef: le,
        gridProps: Ee,
        columnsRef: $(),
        columnsMapRef: G,
        dataRef: g,
        slicedData: O,
        isFixedVirtualScroll: J === j,
        id: R,
        total: v,
        detailExpandable: !!e.detail
      },
      /* @__PURE__ */ l.createElement(Ue, null, /* @__PURE__ */ l.createElement(
        "div",
        {
          id: e.id,
          style: e.style,
          className: f(u.wrapper({ size: E }), e.className),
          "aria-label": e.ariaLabel,
          ...Ke
        },
        oe,
        ce,
        /* @__PURE__ */ l.createElement(
          al,
          {
            selectable: e.selectable,
            className: f(u.table({ size: E }))
          },
          Ce,
          se,
          /* @__PURE__ */ l.createElement($e, { rowReorderable: N }, X)
        ),
        ge && /* @__PURE__ */ l.createElement(ze, null, M.length ? M : /* @__PURE__ */ l.createElement(Oe, null)),
        we && /* @__PURE__ */ l.createElement(l.Fragment, null, /* @__PURE__ */ l.createElement(We, null), /* @__PURE__ */ l.createElement(je, null))
      )),
      de,
      e.pageable && ye,
      /* @__PURE__ */ l.createElement(Qe, { loader: e.loader, showLoader: e.showLoader })
    );
  let W = e.style || {};
  return D && (W.height || (W = Object.assign({}, W, { height: "450px" }))), /* @__PURE__ */ l.createElement(
    Me,
    {
      gridRef: le,
      gridProps: Ee,
      columnsRef: $(),
      columnsMapRef: G,
      dataRef: g,
      slicedData: O,
      isFixedVirtualScroll: J === j,
      id: R,
      total: v,
      detailExpandable: !!e.detail
    },
    /* @__PURE__ */ l.createElement(Ue, null, /* @__PURE__ */ l.createElement(
      "div",
      {
        id: e.id,
        style: W,
        className: f(
          u.wrapper({
            size: E,
            virtual: D
          }),
          e.className
        ),
        "aria-label": e.ariaLabel,
        ...Ke
      },
      oe,
      ce,
      /* @__PURE__ */ l.createElement(
        "div",
        {
          className: f(u.ariaRoot({})),
          role: "grid",
          "aria-colcount": b.length,
          "aria-rowcount": v,
          id: R,
          "aria-label": _.toLanguageString(Je, sl[Je])
        },
        se,
        /* @__PURE__ */ l.createElement("div", { className: f(u.container({})), role: "presentation" }, /* @__PURE__ */ l.createElement(il, null, /* @__PURE__ */ l.createElement("div", { className: f(u.content({})), role: "presentation" }, /* @__PURE__ */ l.createElement("div", { className: f(u.tableWrap({})), role: "presentation" }, /* @__PURE__ */ l.createElement(
          nl,
          {
            selectable: e.selectable,
            tableClassName: f(
              u.table({
                size: E
              })
            ),
            tableStyle: { userSelect: st }
          },
          Ce,
          /* @__PURE__ */ l.createElement($e, { rowReorderable: N }, X)
        ), ge && /* @__PURE__ */ l.createElement(ze, null, M.length ? M : /* @__PURE__ */ l.createElement(Oe, null))), D && /* @__PURE__ */ l.createElement(
          "div",
          {
            className: f(u.heightContainer({})),
            role: "presentation"
          },
          /* @__PURE__ */ l.createElement(ol, { isVirtualScroll: D })
        )))),
        bt,
        we && /* @__PURE__ */ l.createElement(l.Fragment, null, /* @__PURE__ */ l.createElement(We, null), /* @__PURE__ */ l.createElement(je, null)),
        /* @__PURE__ */ l.createElement(tl, null)
      ),
      de,
      e.pageable && ye,
      /* @__PURE__ */ l.createElement(Qe, { loader: e.loader, showLoader: e.showLoader })
    ))
  );
});
hl.displayName = "KendoReactGridComponent";
export {
  hl as GridComponent
};
