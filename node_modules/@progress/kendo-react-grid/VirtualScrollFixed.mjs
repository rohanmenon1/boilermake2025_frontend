/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as f from "react";
import { firefox as d } from "./utils/index.mjs";
class S {
  constructor(t) {
    this.table = null, this.containerHeight = 0, this.topCacheCount = 0, this.attendedSkip = 0, this.propsSkip = 0, this.total = 0, this.scrollableVirtual = !1, this.realSkip = 0, this.pageSize = 0, this.PageChange = null, this.tableBodyRef = null, this.fixedScroll = !1, this.askedSkip = void 0, this.containerRef = null, this.tableTransform = "", this.scrollSyncing = !1, this.lastLoaded = 0, this.firstLoaded = 0, this.lastScrollTop = 0, this.reactVersion = Number.parseFloat(f.version), this.firstLoaded = this.pageSize, this.lastLoaded = this.realSkip + this.pageSize, this.scrollHandler = this.scrollHandler.bind(this);
  }
  get container() {
    var t;
    return ((t = this.containerRef) == null ? void 0 : t.current) || void 0;
  }
  translate(t, i) {
    this.scrollableVirtual && this.table && (d || this.reactVersion <= 17 || i ? this.table.style.transform = "translateY(" + t + "px)" : this.tableTransform = "translateY(" + t + "px)");
  }
  changePage(t, i) {
    this.PageChange && this.PageChange({ skip: Math.max(0, t), take: this.pageSize }, i);
  }
  reset() {
    this.scrollSyncing = !0, !this.fixedScroll && (this.container && (this.container.scrollTop = 0), this.translate(0, !0));
  }
  scrollHandler(t) {
    var h;
    if (!this.scrollableVirtual || !this.container || !this.table || !this.rowHeightService || !((h = this.containerRef) != null && h.current))
      return;
    if (this.scrollSyncing) {
      this.scrollSyncing = !1;
      return;
    }
    const i = this.container.scrollTop, a = this.lastScrollTop >= i, o = !a;
    this.lastScrollTop = i;
    let s = this.rowHeightService.index(i), r = this.rowHeightService.offset(s);
    const { offsetHeight: l } = this.containerRef.current, n = this.rowHeightService.index(i + l);
    if (o && n >= this.lastLoaded && this.lastLoaded < this.total) {
      const e = s + this.pageSize - this.total;
      e > 0 && (s = s - e, r = this.rowHeightService.offset(s)), this.firstLoaded = s, this.translate(r);
      const c = this.firstLoaded + this.pageSize;
      this.lastLoaded = Math.min(c, this.total), this.changePage(this.firstLoaded, t);
    } else if (a && s < this.firstLoaded) {
      const e = Math.floor(this.pageSize * 0.3);
      this.firstLoaded = Math.max(s - e, 0), this.translate(this.rowHeightService.offset(this.firstLoaded)), this.lastLoaded = Math.min(this.firstLoaded + this.pageSize, this.total), this.changePage(this.firstLoaded, t);
    }
  }
}
export {
  S as VirtualScrollFixed
};
